<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthesizer</title>
    <script src="js/jsmediatags.min.js"></script>
    <script src="js/lame.all.js"></script>
    <script src="js/browser-id3-writer.js"></script>
    <script src="js/OggVorbisEncoder.js"></script>
    <script src="js/WebAudioFontPlayer.js"></script>
    <style>
        :root {
            --bg-color: black;
            --code-bg-color: #1a1a1a;
            --text-color: white;
            --border-color: white;
            --op-bg-color: white;
            --op-text-color: black;
            --loop-color: #4CAF50;
            --loop-alt-color: #FF9800;
            --grid-line: #333;
            --grid-beat: #555;
            --grid-bg: #1a1a1a;
            --note-bg: #ffffff;
            --note-selected: darkslateblue;
            --selection-rect: rgba(255, 255, 255, 0.3);
        }

        body.light-theme {
            --bg-color: white;
            --code-bg-color: #f0f0f0;
            --text-color: black;
            --border-color: black;
            --op-bg-color: black;
            --op-text-color: white;
            --loop-color: #2E7D32;
            --loop-alt-color: #E65100;
            --grid-line: #444;
            --grid-beat: #666;
            --grid-bg: #000000;
            --note-bg: #ffffff;
            --note-selected: darkslateblue;
            --selection-rect: rgba(255, 255, 255, 0.3);
        }

        body.retro-light-theme {
            --bg-color: white;
            --code-bg-color: #e0e0e0;
            --text-color: #000000;
            --border-color: #000000;
            --op-bg-color: #e6e6e6;
            --op-text-color: #000000;
            --loop-color: #2da195;
            --loop-alt-color: #b35900;
            --grid-line: #ccc;
            --grid-beat: #999;
            --grid-bg: #e0e0e0;
            --note-bg: #444444; 
            font-family: 'MS Sans Serif', 'Arial', 'Monospace', sans-serif !important;
        }

        body.retro-dark-theme {
            --bg-color: #333333;
            --code-bg-color: #222222;
            --text-color: #f0f0f0;
            --border-color: #f0f0f0;
            --op-bg-color: #333333;
            --op-text-color: #f0f0f0;
            --loop-color: #800000;
            --loop-alt-color: #D2691E;
            --grid-line: #444;
            --grid-beat: #666;
            --grid-bg: #050505;
            --note-bg: #ffffff;
            font-family: 'MS Sans Serif', 'Arial', 'Monospace', sans-serif !important;
        }

        #metadataContainer input { border: 1px solid var(--border-color); width: 100%; border-radius: 5px; box-sizing: border-box; border-style: 1px solid; font-family: Monospace; background-color: var(--bg-color); color: var(--text-color);}
        .retro-dark-theme #metadataContainer input { border-radius: 0; background-color: #1a1a1a; }

        body {
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Monospace', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .hidden { display: none !important; }

        #globalTitle {
            font-size: 1.5em;
            margin: 0 0 20px 0;
            font-weight: bold;
            color: var(--text-color);
            align-self: flex-start;
            width: 100%;
            text-align: center;
            margin-left: 10px;
            cursor: pointer;
            user-select: none;
        }

        .main-layout {
            width: 100%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding-top: 0;
            flex-grow: 1;
        }

        .controls-code-column {
            width: 100%;
            max-width: 700px;
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        #visualizer-container {
            width: 100%;
            margin-bottom: 30px;
            box-sizing: border-box;
            position: relative;
            cursor: pointer;
            overflow: hidden;
        }
        
        #visualizer-container.dragover {
            border-style: dashed;
            opacity: 0.7;
        }
        
        #visualizer-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        body.light-theme #visualizer-indicator {
            background-color: rgba(255, 255, 255, 0.7);
            color: black;
            border: 1px solid rgba(0,0,0,0.2);
        }

        #visualizer {
            background-color: var(--code-bg-color);
            border: 1.7px solid var(--border-color);
            width: 100%;
            height: 100px;
            box-sizing: border-box;
        }
        
        #videoVisualizer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: contain; background-color: var(--code-bg-color); z-index: 2;
        }

        .controls-container {
            background-color: var(--bg-color);
            border: 1.7px solid var(--border-color);
            padding: 20px;
            border-radius: 0;
            width: 100%;
            box-sizing: border-box;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px 30px;
        }

        .control-group { display: flex; flex-direction: column; }
        label { font-weight: bold; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; }
        .value-input-group { display: flex; gap: 10px; align-items: center; width: 100%; }
        input[type="range"] { flex-grow: 1; margin: 0; -webkit-appearance: none; background: var(--border-color); height: 2px; cursor: pointer; }
        input[type="range"].vertical { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 100px; padding: 0 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; border-radius: 0; background: var(--text-color); border: 1px solid var(--border-color); }
        .value-input, select { width: 70px; padding: 5px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); font-family: inherit; font-size: 0.9em; text-align: right; border-radius: 4px; }
        select { width: 100%; box-sizing: border-box; border-radius: 4px; text-align: left; text-align-last: left; min-width: 120px; }

        .action-button-group { grid-column: 1 / -1; display: flex; gap: 10px; margin-top: 10px; }
        
        #advancedToggle { cursor: pointer; font-weight: bold; user-select: none; padding: 10px 20px; border: 1.7px solid var(--border-color); margin-top: 20px; text-align: center; width: 100%; background-color: transparent; color: var(--text-color); font-family: inherit; font-size: 1em; border-radius: 4px; display: flex; justify-content: left; align-items: center; gap: 10px; transition: all 0.1s; }
        #advancedToggle:active { filter: invert(100%); }
        #advancedToggle .arrow { display: inline-block; transition: transform 0.2s; }

        #advancedControlsContainer { display: none; grid-template-columns: 1fr; gap: 20px; padding-top: 20px; }

        .common-btn { flex-grow: 1; padding: 10px 20px; font-size: 1.1em; background-color: var(--op-bg-color); color: var(--op-text-color); border: 2px solid var(--border-color); cursor: pointer; font-family: inherit; border-radius: 8px; transition: all 0.1s; }
        .rec-btn { flex-basis: 60px; flex-grow: 0; padding: 10px; }
        .rec-btn.recording { background-color: #D32F2F; border-color: #D32F2F; color: white; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
        .circle-btn { width: 40px; height: 40px; padding: 0; font-size: 1.1em; background-color: var(--op-bg-color); color: var(--op-text-color); border: 2px solid var(--border-color); cursor: pointer; font-family: inherit; border-radius: 50%; flex-shrink: 0; transition: all 0.1s; }
        .circle-btn.active { background-color: var(--loop-color); color: var(--op-bg-color); border-color: var(--loop-color); }
        .circle-btn.active.alt { background-color: var(--loop-alt-color); border-color: var(--loop-alt-color); }
        
        button:active:not(:disabled) { filter: invert(100%); }
        .rec-btn.recording:active, .circle-btn.active:active { filter: brightness(80%); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        #audioEditorContainer { width: 100%; }
        #progressBarContainer { width: 100%; height: 10px; background-color: var(--code-bg-color); cursor: pointer; margin-bottom: 10px; border: 1.7px solid var(--border-color); border-radius: 10px; }
        #progressBar { width: 0%; height: 100%; background-color: var(--text-color); }
        #equalizerContainer { display: flex; justify-content: space-around; padding: 20px 0; gap: 10px; }
        .eq-band { display: flex; flex-direction: column; align-items: center; font-size: 0.7em; position: relative; }
        .eq-band .tooltip { visibility: hidden; width: 120px; background-color: black; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 1; bottom: 115%; left: 50%; margin-left: -60px; opacity: 0; transition: opacity 0.3s; }
        .eq-band:hover .tooltip { visibility: visible; opacity: 1; }
        #metadataContainer { display: grid; grid-template-columns: 100px 1fr; gap: 10px 20px; align-items: center; }
        #coverArt { width: 100px; height: 100px; object-fit: cover; background-color: var(--code-bg-color); border: 1px solid var(--border-color); cursor: pointer; }
        .metadata-fields { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        #reverseBtn { width: 100%; margin: 10px 0; padding: 10px; font-family: inherit; border: 1px solid var(--border-color); border-radius: inherit; background-color: var(--op-bg-color); color: var(--op-text-color); transition: all 0.1s; }
        #reverseBtn.active { background-color: var(--loop-color); color: var(--op-bg-color); border-color: var(--loop-color); }
        #reverseBtn:disabled { opacity: 0.5; cursor: not-allowed; }

        #codeOutputContainer { background-color: var(--code-bg-color); border: 2px solid var(--border-color); padding: 15px; border-radius: 0; width: 100%; margin-top: 30px; margin-bottom: 0; box-sizing: border-box; transition: all 0.3s ease-in-out; }
        #codeHeader { display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; height: 100%; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #codeHeader div { display: flex; gap: 10px; height: 100%; align-items: center; }
        #codeOutput { width: 100%; height: 250px; border: none; background: none; color: var(--text-color); font-family: 'Monospace', monospace; font-size: 12px; resize: vertical; padding: 10px 0 0 0; box-sizing: border-box; line-height: 1.4; display: block; border-radius: 0; transition: all 0.2s; }
        .code-action-btn { width: 30px; height: 30px; border-radius: 4px; background-color: transparent; border: 1.5px solid var(--border-color); color: var(--text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; font-family: 'Monospace', monospace; box-sizing: border-box; font-size: 14px; line-height: 1; transition: all 0.3s; }
        .code-action-btn:active { filter: invert(100%); }

        .side-buttons-container { position: fixed; top: 20px; z-index: 1000; display: flex; flex-direction: row; gap: 10px; transition: left 0.5s, right 0.5s; }
        .side-buttons-container.right { right: 20px; left: unset; }
        .side-buttons-container.left { left: 20px; right: unset; }
        .side-buttons-container .action-btn { width: 40px; height: 40px; font-size: 18px; border-radius: 50%; background-color: var(--op-bg-color); border: 1.7px solid var(--op-bg-color); color: var(--op-text-color); transform-origin: center center; transition: all 0.1s; }
        .corner-button { position: fixed; top: 0; width: 25vw; height: 5vh; z-index: 999; cursor: pointer; -webkit-tap-highlight-color: transparent; }
        #leftCornerBtn { left: 0; }
        #rightCornerBtn { right: 0; }
        .animate-spin-out { animation: spinShrinkDisappear 0.5s forwards; }
        .animate-spin-in { animation: spinGrowAppear 0.5s forwards; }
        @keyframes spinShrinkDisappear { 0% { transform: rotate(0deg) scale(1); opacity: 1; } 100% { transform: rotate(-720deg) scale(0); opacity: 0; } }
        @keyframes spinGrowAppear { 0% { transform: rotate(0deg) scale(0); opacity: 0; } 14% { transform: rotate(0deg) scale(0.1); opacity: 0; } 100% { transform: rotate(720deg) scale(1); opacity: 1; } }

        #codeModalBackdrop, #exportModalBackdrop, #resetModalBackdrop, #effectsModalBackdrop, #startModalBackdrop { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; align-items: center; justify-content: center; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
        #codeModalBackdrop.visible, #exportModalBackdrop.visible, #resetModalBackdrop.visible, #effectsModalBackdrop.visible, #startModalBackdrop.visible { display: flex; opacity: 1; pointer-events: auto; }
        .glass-panel { background-color: rgba(255, 255, 255, 0.15); border: 1.5px solid rgba(255, 255, 255, 0.4); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3); border-radius: 8px; transition: all 0.3s ease-in-out; }
        body.light-theme .glass-panel { background-color: rgba(255, 255, 255, 0.6); border: 1.5px solid rgba(0, 0, 0, 0.3); }
        .retro-light-theme .glass-panel, .retro-dark-theme .glass-panel { backdrop-filter: none; -webkit-backdrop-filter: none; background-color: var(--bg-color); border: 2px outset var(--border-color); box-shadow: none; border-radius: 0; }
        #codeModalPanel, #exportModalPanel, #resetModalPanel, #effectsModalPanel, #startModalPanel { position: relative; width: 90%; max-width: 650px; max-height: 80vh; overflow: hidden; padding: 15px; box-sizing: border-box; color: var(--text-color); transform: scale(0.95); display: flex; flex-direction: column; }
        #exportModalPanel, #resetModalPanel, #startModalPanel { max-width: 400px; text-align: center; }
        #effectsModalPanel { max-width: 500px; }
        #codeModalBackdrop.visible #codeModalPanel, #exportModalBackdrop.visible #exportModalPanel, #resetModalBackdrop.visible #resetModalPanel, #effectsModalBackdrop.visible #effectsModalPanel, #startModalBackdrop.visible #startModalPanel { transform: scale(1); }
        #codeModalPanel #codeOutputContainer { margin-top: 0 !important; padding: 0 !important; border: none !important; background-color: transparent !important; max-height: 100%; }
        #codeModalPanel #codeOutput { height: calc(80vh - 100px); resize: none !important; overflow: auto; }
        
        .export-options { display: flex; gap: 15px; margin-bottom: 20px; justify-content: center; }
        .export-options button { flex-grow: 1; padding: 12px; font-size: 1.1em; cursor: pointer; font-family: inherit; background-color: var(--op-bg-color); color: var(--op-text-color); border: 1.7px solid var(--border-color); border-radius: 8px; transition: all 0.1s; }
        .export-options button:active { filter: invert(100%); }
        #closeExportModalBtn, #closeEffectsModalBtn { width: 100%; padding: 10px; background: transparent; border: 1.7px solid var(--border-color); color: var(--text-color); border-radius: 8px; cursor: pointer; font-family: inherit; }
        #closeExportModalBtn:active, #closeEffectsModalBtn:active { background-color: var(--code-bg-color); }
        .export-note { font-size: 0.8em; color: #888; margin-top: 20px; margin-bottom: 0px; }

        .retro-light-theme *, .retro-dark-theme * { transition: none !important; border-radius: 0 !important;}
        .retro-light-theme button, .retro-dark-theme button, .retro-light-theme .code-action-btn, .retro-dark-theme .code-action-btn { border-style: outset; border-width: 2px; filter: none !important; }
        .retro-light-theme button:active:not(:disabled), .retro-dark-theme button:active:not(:disabled) { border-style: inset; }
        .retro-light-theme .common-btn, .retro-light-theme .circle-btn { background-color: #dedede; color: black;}
		.retro-dark-theme .common-btn, .retro-dark-theme .circle-btn { background-color: #121212; color: white;}
        .retro-light-theme .controls-container, .retro-dark-theme .controls-container { border-style: outset; border-width: 2.5px; border-color: var(--border-color);}
        .retro-light-theme input[type="text"], .retro-dark-theme input[type="text"], .retro-light-theme input[type="number"], .retro-dark-theme input[type="number"], .retro-light-theme select, .retro-dark-theme select { border-style: inset; border-width: 2px; background-color: var(--code-bg-color); }
        
        #mobile-fixed-buttons { display: none; }

        #workstationContainer { width: 100%; height: 100%; display: flex; flex-direction: column; gap: 10px; max-width: 1400px; margin-top: 20px;}
        .ws-top-bar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; background: var(--code-bg-color); padding: 10px; border: 2px solid var(--border-color); }
        .ws-controls { display: flex; gap: 5px; flex-grow: 1;}
        .ws-controls button { min-width: 35px; width: auto; height: 35px; font-weight: bold; cursor: pointer; background: var(--op-bg-color); color: var(--op-text-color); border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; padding: 0 10px; }
        .ws-controls button.rounded { border-radius: 20px; }
        .ws-controls button:active, .ws-controls button.active { filter: invert(100%); }
        .ws-controls button#wsRecBtn.recording { background-color: #D32F2F; color: white; border-color: red; }
        .ws-controls button#wsLassoBtn.active { background-color: #D32F2F; color: white; border-color: red; filter: none; }
        .ws-info { display: flex; gap: 15px; align-items: center; font-size: 0.9em; margin-left: 10px; flex-wrap: wrap; }
        .ws-info input { width: 50px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 2px; text-align: center; font-family: inherit; }
        .ws-info-group { display: flex; gap: 5px; align-items: center; }
        
        #sequencerArea { display: flex; flex-direction: column; flex-grow: 1; border: 2px solid var(--border-color); background: var(--code-bg-color); height: 40vh; min-height: 400px; position: relative; overflow: hidden; }
        #trackList { width: 200px; border-right: 2px solid var(--border-color); display: flex; flex-direction: column; overflow-y: auto; flex-shrink: 0; background: var(--bg-color); }
        .track-header { padding: 10px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 0.8em; cursor: pointer; user-select: none; height: 60px; box-sizing: border-box;}
        .track-header.selected { background: rgba(128,128,128,0.3); }
        .track-controls { display: flex; gap: 5px; }
        .track-btn { width: 20px; height: 20px; padding: 0; font-size: 10px; border: 1px solid var(--border-color); background: transparent; color: var(--text-color); cursor: pointer; }
        
        #pianoRollContainer { flex-grow: 1; display: flex; position: relative; overflow: hidden; }
        #keysSidebar { width: 50px; flex-shrink: 0; background: var(--bg-color); border-right: 1px solid var(--border-color); overflow: hidden; position: relative; }
        .piano-key { border-bottom: 1px solid var(--border-color); box-sizing: border-box; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; font-size: 10px; color: #888; position: relative; cursor: pointer; }
        .piano-key.black { background: #333; color: white; }
        .piano-key.white { background: #fff; color: black; }
        .piano-key.active { background: var(--loop-color) !important; }

        #gridContainer { flex-grow: 1; overflow: scroll; position: relative; background: var(--code-bg-color); cursor: crosshair; }
        #gridCanvas { position: absolute; top: 0; left: 0; }
        .note-block { position: absolute; height: 18px; background: var(--note-bg); border: 1px solid rgba(0,0,0,0.3); box-sizing: border-box; border-radius: 2px; cursor: grab; z-index: 10; opacity: 0.7; }
        .note-block.selected { background: var(--note-selected); border-color: white; opacity: 0.9; }
        .note-block.resizing-mobile { border: 2px dashed red; opacity: 0.8; }
        .note-block.moving-mobile { border: 2px solid var(--loop-color); opacity: 0.8; }
        .note-resize-handle { position: absolute; right: 0; top: 0; width: 5px; height: 100%; cursor: e-resize; }
        #selectionRect { position: absolute; background: var(--selection-rect); border: 1px solid var(--note-bg); z-index: 15; display: none; pointer-events: none; }
        
        #playhead { position: absolute; top: 0; width: 2px; height: 100%; background: var(--loop-alt-color); z-index: 20; pointer-events: auto; cursor: pointer; left: 0; will-change: transform; transform: translateZ(0); }
        #playhead:hover { width: 4px; margin-left: -1px; }
        
        #ws-playlist-name { background: transparent; border: none; border-bottom: 1px solid var(--border-color); color: var(--text-color); font-family: inherit; font-size: 1em; width: 150px; }

        #addTrackMenu, #trackContextMenu, #gridContextMenu, #typeSelectMenu { position: absolute; background: var(--bg-color); border: 1px solid var(--border-color); z-index: 200; display: none; flex-direction: column; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        #addTrackMenu button, #trackContextMenu button, #gridContextMenu button, #typeSelectMenu button { padding: 10px; text-align: left; background: transparent; color: var(--text-color); border: none; cursor: pointer; font-family: inherit; min-width: 120px; border-bottom: 1px solid var(--border-color); }
        #addTrackMenu button:last-child, #trackContextMenu button:last-child, #gridContextMenu button:last-child, #typeSelectMenu button:last-child { border-bottom: none; }
        #addTrackMenu button:hover, #trackContextMenu button:hover, #gridContextMenu button:hover, #typeSelectMenu button:hover { background: var(--op-bg-color); color: var(--op-text-color); }

        .scrollable-menu { max-height: 300px; overflow-y: auto; min-width: 200px !important; }

        #keysContainer { width: 100%; display: flex; flex-direction: column; gap: 5px; flex-shrink: 0; }
        #keysControlBar { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        #keysControlBar .ws-info-group button { min-width: 30px; height: 30px; font-weight: bold; cursor: pointer; background: var(--op-bg-color); color: var(--op-text-color); border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; }
        #keysControlBar .ws-info-group button:active { filter: invert(100%); }
        #wsKeysBtn { width: 100px; border-radius: 20px; padding: 8px; cursor: pointer; border: 1px solid var(--border-color); background: var(--op-bg-color); color: var(--op-text-color); }
        #wsKeysBtn.active { background-color: black; color: white; border-color: var(--border-color); }
        #mobileKeyboard { display: none; flex-direction: column; gap: 6px; height: 220px; margin-top: 10px; background: var(--bg-color); border: 2px solid var(--border-color); flex-shrink: 0; padding: 5px 0; }
        .mobile-key-row { position: relative; flex: 1; width: 100%; display: flex; background: var(--bg-color); }
        .mobile-key.white { flex: 1; border: 1px solid #ccc; background: white; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; z-index: 1; height: 100%; box-sizing: border-box; display: flex; align-items: flex-end; justify-content: center; font-size: 0.6em; color: #555; padding-bottom: 2px; }
        .mobile-key.black { position: absolute; width: 4%; height: 60%; background: black; z-index: 10; border-bottom-left-radius: 2px; border-bottom-right-radius: 2px; box-sizing: border-box; border: 1px solid #555; }
        .mobile-key.white:active, .mobile-key.white.active-touch { background: #ddd; transform: scale(0.98); }
        .mobile-key.black:active, .mobile-key.black.active-touch { background: #333; transform: scale(0.98); }
        .mobile-key.active-touch { background: var(--loop-color) !important; }
        #mobilePitchInput { width: 24px; height: 24px; text-align: center; margin: 0 5px; } 

        #dpadContainer {
            position: fixed; bottom: 100px; right: 20px; width: 120px; height: 120px;
            background-color: rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-radius: 50%; display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 900; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        body.light-theme #dpadContainer { background-color: rgba(255, 255, 255, 0.6); border: 1px solid rgba(0,0,0,0.2); }
        .dpad-row { display: flex; justify-content: center; width: 100%; }
        .dpad-btn {
            width: 35px; height: 35px; border: none; background: transparent; color: var(--text-color);
            font-size: 1.2em; cursor: pointer; display: flex; align-items: center; justify-content: center;
            user-select: none; -webkit-user-select: none;
        }
        .dpad-btn:active { filter: brightness(0.7); transform: scale(0.95); }
        #dpadDragBtn { cursor: grab; font-size: 1.5em; }
        
        #resizeControls { position: absolute; display: none; z-index: 50; pointer-events: none; }
        .resize-btn { 
            pointer-events: auto; background: black; color: white; border: 1px solid #555; 
            width: 30px; height: 20px; font-size: 12px; cursor: pointer; display: flex; 
            align-items: center; justify-content: center; margin-right: 5px; border-radius: 4px; 
        }
        #dragHandle {
            position: absolute; display: none; width: 30px; height: 30px; z-index: 50; 
            background: black; border-radius: 50%; cursor: move; opacity: 0.8;
            align-items: center; justify-content: center; color: white; font-size: 18px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        #canvasOptionsBtn {
            position: absolute; top: 10px; right: 10px; width: 20px; height: 20px; z-index: 100;
            background-color: var(--op-bg-color); color: var(--op-text-color); border: 1px solid var(--border-color);
            border-radius: 20%; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 0.9em;
        }
        #canvasOptionsBtn:active { filter: invert(100%); }
        
        .grid-corner-trigger {
            position: absolute; width: 40px; height: 40px; z-index: 90; background: transparent; cursor: pointer;
        }
        #gridCornerTR { top: 0; right: 0; }
        #gridCornerTL { top: 0; left: 50px; }
        #gridCornerBL { bottom: 0; left: 50px; }
        
        #zoomControls {
            position: absolute; bottom: 10px; right: 10px; z-index: 100; display: flex; gap: 5px;
        }
        .zoom-btn {
            width: 30px; height: 30px; background-color: var(--op-bg-color); color: var(--op-text-color); border: 1px solid var(--border-color);
            font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2em;
        }
        .zoom-btn:active { filter: invert(100%); }

        body:not(.retro-light-theme):not(.retro-dark-theme) .ws-controls button,
        body:not(.retro-light-theme):not(.retro-dark-theme) .ws-info input,
        body:not(.retro-light-theme):not(.retro-dark-theme) .ws-info select,
        body:not(.retro-light-theme):not(.retro-dark-theme) .track-header,
        body:not(.retro-light-theme):not(.retro-dark-theme) .ws-top-bar,
        body:not(.retro-light-theme):not(.retro-dark-theme) #sequencerArea,
        body:not(.retro-light-theme):not(.retro-dark-theme) #trackList,
        body:not(.retro-light-theme):not(.retro-dark-theme) #pianoRollContainer,
        body:not(.retro-light-theme):not(.retro-dark-theme) #keysSidebar,
        body:not(.retro-light-theme):not(.retro-dark-theme) #keysControlBar .ws-info-group button,
        body:not(.retro-light-theme):not(.retro-dark-theme) .zoom-btn {
            border-radius: 6px;
        }

        .track-header { margin-bottom: 4px; }

        body:not(.retro-light-theme):not(.retro-dark-theme) #addTrackMenu,
        body:not(.retro-light-theme):not(.retro-dark-theme) #trackContextMenu,
        body:not(.retro-light-theme):not(.retro-dark-theme) #gridContextMenu,
        body:not(.retro-light-theme):not(.retro-dark-theme) #typeSelectMenu {
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #addTrackMenu,
        body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #trackContextMenu,
        body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #gridContextMenu,
        body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #typeSelectMenu {
            background-color: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0,0,0,0.2);
        }

        @media (min-width: 769px) {
            body { padding: 20px; }
            #globalTitle { margin: 0 0 20px 0; align-self: center; text-align: center; }
            .main-layout { flex-direction: row; justify-content: center; align-items: center; gap: 50px; height: calc(100vh - 40px); max-height: 800px; }
            .controls-code-column { display: flex; flex-direction: row; gap: 50px; max-width: none; width: 100%; height: 100%; justify-content: center; }
            #visualizer-container { order: 1; height: 100%; aspect-ratio: 1 / 1; margin: 0; padding: 0; align-self: center; border: 2px solid var(--border-color); max-width: calc(50% - 25px); }
            #visualizer, #videoVisualizer { height: 100%; border: none; }
            .controls-group-right { order: 2; display: flex; flex-direction: column; height: 100%; aspect-ratio: 1 / 1; padding-top: 0; border: 2px solid var(--border-color); background-color: var(--bg-color); max-width: calc(50% - 25px); }
            #scrollableControls { overflow-y: auto; flex-grow: 1; padding: 20px; }
            .controls-container { grid-template-columns: 1fr 1fr; gap: 15px 20px; border: none; padding: 0; }
            #advancedControlsContainer { grid-template-columns: 1fr 1fr; gap: 15px 20px; }
            #codeOutputContainer { margin-top: 30px; height: auto; border-top: 2px solid var(--border-color); border-left: none; border-right: none; border-bottom: none; }
            #stickyActions { flex-shrink: 0; padding: 20px; border-top: 2px solid var(--border-color); }
            body:not(.retro-light-theme):not(.retro-dark-theme) #stickyActions { background-color: rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
            body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #stickyActions { background-color: rgba(255, 255, 255, 0.6); }
            .value-input, select { width: 50px; }
            .value-input-group { gap: 5px; }
            #workstationContainer { height: calc(100vh - 100px); }
        }

        @media (max-width: 768px) {
            body { padding: 60px 10px 100px 10px; } 
            .header-fixed { position: fixed; top: 0; left: 0; right: 0; z-index: 20; background-color: var(--bg-color); border-bottom: 1.7px solid var(--border-color); }
            #globalTitle { padding: 10px 10px 0 10px; margin: 0; height: 50px; box-sizing: border-box; }
            .side-buttons-container { top: 5px; left: 10px; right: unset; bottom: unset; }
            .side-buttons-container.right { right: 10px; left: unset; }
            .side-buttons-container .action-btn { width: 35px; height: 35px; }
            .controls-code-column { flex-direction: column; gap: 0; max-width: 100%; width: 100%; margin-top: 150px; }
            #visualizer-container { position: fixed; top: 50px; left:0; right: 0; z-index: 10; margin-bottom: 0; padding: 10px; border: none; border-bottom: 1.7px solid var(--border-color); height: 150px; max-width: 100%; background-color: var(--bg-color); }
            #visualizer, #videoVisualizer { height: 100%; border: none; }
            .controls-group-right { width: 100%; }
            .controls-container { grid-template-columns: 1fr; padding: 20px 10px; gap: 12px 10px; border-top: none; }
            #audioEditorContainer { left:0; right: 0; overflow-x: hidden; flex-grow: 1; max-width: 95%; margin-left:auto; margin-right:auto; .control-group { width: 100%; display: flex; flex-direction: column;} }
            #advancedControlsContainer { grid-template-columns: 1fr; }
            .action-button-group { display: none; }
            #mobile-fixed-buttons { display: flex; position: fixed; bottom: 0; left: 0; right: 0; z-index: 10; padding: 15px 10px; background-color: var(--bg-color); border-top: 1.7px solid var(--border-color); gap: 10px; }
            body:not(.retro-light-theme):not(.retro-dark-theme) #visualizer-container, body:not(.retro-light-theme):not(.retro-dark-theme) #mobile-fixed-buttons { background-color: rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
            body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #visualizer-container, body.light-theme:not(.retro-light-theme):not(.retro-dark-theme) #mobile-fixed-buttons { background-color: rgba(255, 255, 255, 0.6); }
            #mobile-fixed-buttons .circle-btn { width: 50px; height: 50px; border-radius: 20%; } 
            #mobile-fixed-buttons .common-btn { border-radius: 8px; }
            #mobile-fixed-buttons .rec-btn { flex-grow: 0; flex-basis: 70px; }
            #codeOutputContainer { margin-top: 30px; }
            .value-input, select { width: 70px; }
            #workstationContainer { margin-top: 60px; height: calc(100vh - 180px); border-width: 1.5px; }
            #trackList { width: 120px; }
            .ws-top-bar { gap: 5px; }
            #effectsModalPanel { max-width: 90%; }
            #sequencerArea { height: calc(60vh - 150px); }
            .ws-top-bar, #sequencerArea, #keysSidebar, #gridContainer, #trackList, #mobileKeyboard { border-width: 1.5px; }
        }
    </style>
</head>
<body id="body">
    <input type="file" id="audioFileInput" class="hidden" accept="audio/*,video/mp4">
    <input type="file" id="coverArtInput" class="hidden" accept="image/*">
    <input type="file" id="jsonLoadInput" class="hidden" accept=".json">
    <div class="header-fixed">
        <h1 id="globalTitle">./SYNTH.</h1>
    </div>
    
    <div class="main-layout" id="synthLayout">
        <!-- (Same structure as before) -->
        <div class="controls-code-column">
            <div id="visualizer-container">
                <canvas id="visualizer"></canvas>
                <video id="videoVisualizer" class="hidden" muted playsinline></video>
                <div id="visualizer-indicator"></div>
            </div>
            
            <div class="controls-group-right"> 
                <div id="scrollableControls">
                    <div id="synthControls">
                         <!-- (Synth controls same as before) -->
                        <div class="controls-container">
                            <div class="control-group"><label for="waveType">Wave Type</label><select id="waveType" oninput="saveSettings(); generateCode(); if (loopMode > 0) playCustomSound();"></select></div>
                            <div class="control-group"><label for="filterType">Filter Type</label><select id="filterType" oninput="saveSettings(); generateCode(); if (loopMode > 0) playCustomSound();"></select></div>
                            <div class="control-group"><label for="startFreq">Start Frequency (Hz)</label><div class="value-input-group"><input type="range" id="startFreq" min="50" max="4000" step="1" value="1000" data-link="startFreqInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="startFreqInput" class="value-input" min="50" max="4000" step="1" value="1000" data-link="startFreq" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="endFreq">End Frequency (Hz)</label><div class="value-input-group"><input type="range" id="endFreq" min="50" max="4000" step="1" value="1000" data-link="endFreqInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="endFreqInput" class="value-input" min="50" max="4000" step="1" value="1000" data-link="endFreq" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="audioDuration">Note Duration (s)</label><div class="value-input-group"><input type="range" id="audioDuration" min="0.1" max="5.0" step="0.1" value="0.7" data-link="audioDurationInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="audioDurationInput" class="value-input" min="0.1" max="5.0" step="0.1" value="0.7" data-link="audioDuration" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="decayTime">Decay Time (s)</label><div class="value-input-group"><input type="range" id="decayTime" min="0.01" max="0.5" step="0.01" value="0.07" data-link="decayTimeInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="decayTimeInput" class="value-input" min="0.01" max="0.5" step="0.01" value="0.07" data-link="decayTime" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="attackTime">Attack Time (s)</label><div class="value-input-group"><input type="range" id="attackTime" min="0.001" max="0.1" step="0.001" value="0.005" data-link="attackTimeInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="attackTimeInput" class="value-input" min="0.001" max="0.1" step="0.001" value="0.005" data-link="attackTime" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="filterFreq">Filter Frequency (Hz)</label><div class="value-input-group"><input type="range" id="filterFreq" min="20" max="4000" step="1" value="4000" data-link="filterFreqInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="filterFreqInput" class="value-input" min="20" max="4000" step="1" value="4000" data-link="filterFreq" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="filterQ">Filter Q (Resonance)</label><div class="value-input-group"><input type="range" id="filterQ" min="0.1" max="30" step="0.1" value="1.0" data-link="filterQInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="filterQInput" class="value-input" min="0.1" max="30" step="0.1" value="1.0" data-link="filterQ" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="sustainLevel">Sustain Level (0.0-1.0)</label><div class="value-input-group"><input type="range" id="sustainLevel" min="0.0001" max="1.0" step="0.0001" value="0.5" data-link="sustainLevelInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="sustainLevelInput" class="value-input" min="0.0001" max="1.0" step="0.0001" value="0.5" data-link="sustainLevel" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                        </div>
                        <button id="advancedToggle">•••<span class="arrow"></span><span id="msg1" style="opacity: 1; transition: opacity 0.5s ease-in-out; font-size: small; color: #888;">(Tap For ADV Controls)</span><script>document.addEventListener('DOMContentLoaded', function() { setTimeout(() => { document.getElementById('msg1').style.opacity = '0'; }, 3000); });</script></button>
                        <div id="advancedControlsContainer">
                            <div class="control-group"><label for="releaseTime">Release Time (s)</label><div class="value-input-group"><input type="range" id="releaseTime" min="0.01" max="2.0" step="0.01" value="0.1" data-link="releaseTimeInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="releaseTimeInput" class="value-input" min="0.01" max="2.0" step="0.01" value="0.1" data-link="releaseTime" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="lfoRate">LFO Rate (Hz)</label><div class="value-input-group"><input type="range" id="lfoRate" min="0.1" max="20" step="0.1" value="5.0" data-link="lfoRateInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="lfoRateInput" class="value-input" min="0.1" max="20" step="0.1" value="5.0" data-link="lfoRate" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="lfoDepth">LFO Depth (Freq Mod)</label><div class="value-input-group"><input type="range" id="lfoDepth" min="0.0" max="1000.0" step="1.0" value="0.0" data-link="lfoDepthInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="lfoDepthInput" class="value-input" min="0.0" max="1000.0" step="1.0" value="0.0" data-link="lfoDepth" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="delayTime">Delay Time (s)</label><div class="value-input-group"><input type="range" id="delayTime" min="0.0" max="1.0" step="0.01" value="0.3" data-link="delayTimeInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="delayTimeInput" class="value-input" min="0.0" max="1.0" step="0.01" value="0.3" data-link="delayTime" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="feedback">Delay Feedback (0.0-0.95)</label><div class="value-input-group"><input type="range" id="feedback" min="0.0" max="0.95" step="0.01" value="0.0" data-link="feedbackInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="feedbackInput" class="value-input" min="0.0" max="0.95" step="0.01" value="0.0" data-link="feedback" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="delayMix">Delay Mix (0.0-1.0)</label><div class="value-input-group"><input type="range" id="delayMix" min="0.0" max="1.0" step="0.01" value="0.0" data-link="delayMixInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="delayMixInput" class="value-input" min="0.0" max="1.0" step="0.01" value="0.0" data-link="delayMix" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="distortionAmount">Distortion Amount</label><div class="value-input-group"><input type="range" id="distortionAmount" min="0" max="1000" step="1" value="0" data-link="distortionAmountInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="distortionAmountInput" class="value-input" min="0" max="1000" step="1" value="0" data-link="distortionAmount" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="reverbMix">Reverb Mix (0.0-1.0)</label><div class="value-input-group"><input type="range" id="reverbMix" min="0.0" max="1.0" step="0.01" value="0.0" data-link="reverbMixInput" oninput="linkSlider(this); generateCode(); if (loopMode > 0) playCustomSound();"><input type="number" id="reverbMixInput" class="value-input" min="0.0" max="1.0" step="0.01" value="0.0" data-link="reverbMix" oninput="linkInput(this); generateCode(); if (loopMode > 0) playCustomSound();"></div></div>
                            <div class="control-group"><label for="masterVolume">Master Volume (dB)</label><div class="value-input-group"><input type="range" id="masterVolume" min="-60" max="60" step="0.1" value="0"><input type="number" id="masterVolumeInput" class="value-input" min="-60" max="60" step="0.1" value="0"></div></div>
                        </div>
                    </div>
                    
                    <div id="audioEditorContainer" class="hidden">
                    	<!-- (Same editor controls) -->
                    	<div id="metadataContainer"><img id="coverArt" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="Cover Art"><div class="metadata-fields"><input type="text" id="metaTitle" placeholder="Title"><input type="text" id="metaArtist" placeholder="Artist"><input type="text" id="metaAlbum" placeholder="Album"><input type="text" id="metaAlbumArtist" placeholder="Album Artist"><input type="text" id="metaTrack" placeholder="Track"><input type="text" id="metaGenre" placeholder="Genre"><input type="text" id="metaYear" placeholder="Year"></div></div>
                        <div id="audioFileInfoContainer" style="margin-top: 15px; font-size: 0.8em; color: #888;"></div><br>
                    	<div id="progressBarContainer"><div id="progressBar"></div></div>
                        <div id="equalizerContainer"></div>
                        <button id="reverseBtn">Reverse</button>
                        <div class="control-group"><label for="editorVolume">Master Volume (dB)</label><div class="value-input-group"><input type="range" id="editorVolume" min="-50" max="50" step="0.1" value="0"><input type="number" id="editorVolumeInput" class="value-input" min="-50" max="50" step="0.1" value="0"></div></div>
                        <div class="control-group"><label for="playbackRate">Speed</label><div class="value-input-group"><input type="range" id="playbackRate" min="0.1" max="3.0" step="0.01" value="1.0"><input type="number" id="playbackRateInput" class="value-input" min="0.1" max="3.0" step="0.01" value="1.0"></div></div>	  
                        <div class="control-group"><label for="editorDistortion">Distortion</label><div class="value-input-group"><input type="range" id="editorDistortion" min="0" max="1000" step="1" value="0"><input type="number" id="editorDistortionInput" class="value-input" min="0" max="1000" step="1" value="0"></div></div>
                        <div class="control-group"><label for="editorBitrate">Bitrate (Bitcrush)</label><div class="value-input-group"><input type="range" id="editorBitrate" min="1" max="16" step="1" value="16"><input type="number" id="editorBitrateInput" class="value-input" min="1" max="16" step="1" value="16"></div></div>
                        <div class="control-group"><label for="editorReverb">Reverb</label><div class="value-input-group"><input type="range" id="editorReverb" min="0" max="1" step="0.01" value="0"><input type="number" id="editorReverbInput" class="value-input" min="0" max="1" step="0.01" value="0"></div></div>
                         <div class="control-group"><label for="editorPan">Pan (-1 L / 1 R)</label><div class="value-input-group"><input type="range" id="editorPan" min="-1" max="1" step="0.01" value="0"><input type="number" id="editorPanInput" class="value-input" min="-1" max="1" step="0.01" value="0"></div></div>
                    </div> 
                    
                    <div id="codeOutputContainer">
                        <div id="codeHeader" onclick="openModalFor('codeOutputContainer')"><span style="font-size: 1.1em;">Code Script (.js) </span><div><button class="code-action-btn" id="editBtn" onclick="editCode(event)">⌨</button><button class="code-action-btn" onclick="copyCode(event)">⛶</button></div></div>
                        <textarea id="codeOutput" readonly></textarea>
                    </div>
                </div>
                
                <div id="stickyActions">
                    <div class="action-button-group">
                        <button id="loopBtn" class="circle-btn" onclick="toggleLoop()"><b>∞</b></button>
                        <button id="shuffleVisualizerBtn" class="circle-btn" onclick="shuffleVisualizer()"><b>⌘</b></button>
                        <button id="recBtn" class="common-btn rec-btn hidden" onclick="toggleRecording()"><b>REC</b></button>
                        <button id="playBtn" class="common-btn" onclick="playCustomSound()">SOUND</button>
                        <button id="addToSeqBtn" class="common-btn" onclick="addToSequencer()">Add to Seq</button>
                        <button id="ejectBtn" class="circle-btn hidden" onclick="ejectAudio()"><b>⏏</b></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="workstationContainer" class="hidden">
        <div class="ws-top-bar">
            <input type="text" id="ws-playlist-name" placeholder="Untitled Project" value="Untitled">
            <div class="ws-controls">
                <button onclick="DAW.togglePlay()" id="wsPlayBtn">►</button>
                <button onclick="DAW.stop()">■</button>
                <button onclick="DAW.toggleLasso()" id="wsLassoBtn">⬚</button>
                <button onclick="DAW.toggleDrawMode()" id="wsDrawBtn">♫</button>
                <button onclick="DAW.toggleRec()" id="wsRecBtn">REC</button>
                <button onclick="DAW.showEffects()">Effect</button>
                <div style="flex-grow: 1;"></div>
                <button onclick="DAW.undo()">&#60;</button>
                <button onclick="DAW.redo()">&#62;</button>
            </div>
            <div class="ws-info">
                <div class="ws-info-group"><label>Timer</label><input type="text" id="wsTimeLimit" value="00:00:30" onchange="DAW.updateSettings()" style="width: 100px;"></div>
                <div class="ws-info-group"><label>Grid</label><select id="wsGridSnap" onchange="DAW.updateSettings()" style="width: 60px;"><option value="4">1/4</option><option value="8">1/8</option><option value="16" selected>1/16</option><option value="32">1/32</option></select></div>
                <div class="ws-info-group"><label>Pitch</label><div class="value-input-group"><input type="range" id="wsTranspose" min="-12" max="12" step="1" value="1" oninput="DAW.updateTranspose(this.value)"><input type="number" id="wsTransposeInput" value="1" oninput="DAW.updateTranspose(this.value)" style="width: 40px;"></div></div>
				<div class="ws-info-group"><label>Vol</label><div class="value-input-group" style="width: 100px;"><input type="range" id="wsTrackVol" min="0" max="2" step="0.1" value="0.5" oninput="DAW.updateTrackVol(this)"><input type="number" id="wsTrackVolInput" min="0" max="2" step="0.1" value="0.5" oninput="DAW.updateTrackVol(this)" onchange="if(this.value.startsWith('.')) this.value='0'+this.value; DAW.updateTrackVol(this)" style="width: 35px;"></div></div>
            </div>
        </div>
        
        <div id="sequencerArea">
            <div style="display: flex; flex-grow: 1; overflow: hidden;">
                <div id="trackList"></div>
                <div id="pianoRollContainer" style="position: relative;">
                    <div id="keysSidebar"></div>
                    <div id="gridContainer">
                        <canvas id="gridCanvas"></canvas>
                        <div id="playhead"></div>
                        <div id="selectionRect"></div>
                        <div id="dpadContainer">
                            <div class="dpad-row"><button class="dpad-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.dpadMove(0, 1)">△</button></div>
                            <div class="dpad-row">
                                <button class="dpad-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.dpadMove(-1, 0)">◁</button>
                                <button class="dpad-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" id="dpadDragBtn">✥</button>
                                <button class="dpad-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.dpadMove(1, 0)">▷</button>
                            </div>
                            <div class="dpad-row"><button class="dpad-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.dpadMove(0, -1)">▽</button></div>
                        </div>
                        <div id="resizeControls">
                            <div class="resize-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.resizeSelection(-1)">-</div>
                            <div class="resize-btn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.resizeSelection(1)">+</div>
                        </div>
                        <div id="dragHandle">✥</div>
                    </div>
                    <button id="canvasOptionsBtn" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()" onclick="event.stopPropagation(); DAW.showGridContext(event)">•••</button>
                    <div id="gridCornerTR" class="grid-corner-trigger" onclick="event.stopPropagation(); DAW.moveOptionsBtn('tr')"></div>
                    <div id="gridCornerTL" class="grid-corner-trigger" onclick="event.stopPropagation(); DAW.moveOptionsBtn('bl')"></div>
                    <div id="gridCornerBL" class="grid-corner-trigger" onclick="event.stopPropagation(); DAW.moveOptionsBtn('bl')"></div>
                    <div id="zoomControls">
                         <button class="zoom-btn" onclick="DAW.zoom(-0.2)">-</button>
                         <button class="zoom-btn" onclick="DAW.zoom(0.2)">+</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="keysContainer">
            <div id="keysControlBar">
                <button id="wsKeysBtn" class="rounded" onclick="DAW.toggleKeys()" style="width: 30%;">Keys ⌨</button>
                
                	<div class="ws-info-group" style="border: 1.5px solid var(--border-color); padding: 2px; border-radius: 9px">
	                    <button onclick="DAW.toggleRec()" id="mobileRecBtn">REC</button>
	                    Ocataves <div class="ws-info"><input type="number" id="mobilePitchInput" value="0" readonly></div>
						<!-- You have found me, an easter egg. -->
						<button onclick="DAW.incrementMobileOctave(-1)">⊖</button>
	                    <button onclick="DAW.incrementMobileOctave(1)">⊕</button>
                	</div>
           	 </div>
            <div id="mobileKeyboard"></div>
        </div>
    </div>
    
    <div id="mobile-fixed-buttons">
        <button id="mobLoopBtn" class="circle-btn" onclick="toggleLoop()"><b>∞</b></button>
        <button id="mobShuffleVisualizerBtn" class="circle-btn" onclick="shuffleVisualizer()"><b>⌘</b></button>
        <button id="mobRecBtn" class="common-btn rec-btn hidden" onclick="toggleRecording()"><b>REC</b></button>
        <button id="mobPlayBtn" class="common-btn" onclick="playCustomSound()"><b>SOUND</b></button>
        <button id="mobAddToSeqBtn" class="common-btn" onclick="addToSequencer()"><b>✛</b></button> 
        <button id="mobEjectBtn" class="circle-btn hidden" onclick="ejectAudio()"><b>⏏</b></button>
    </div>

    <div class="side-buttons-container left" id="sideButtons">
        <button class="action-btn" id="resetBtn" onclick="resetButtonAction(event)">⊘</button>
        <button class="action-btn" id="themeToggleBtn" onclick="toggleTheme()">⽉</button>
        <button class="action-btn" id="exportBtn" onclick="exportButtonAction(event)">E</button>
    </div>

    <div class="corner-button" id="leftCornerBtn"></div><div class="corner-button" id="rightCornerBtn"></div>
    <div id="codeModalBackdrop" class="hidden"><div id="codeModalPanel" class="glass-panel"></div></div>

    <div id="startModalBackdrop" class="hidden">
        <div id="startModalPanel" class="glass-panel" style="text-align: center;">
            <h3>Select Default Mode</h3>
            <div class="export-options">
                <button onclick="setDefaultMode(0)">SYNTH</button>
                <button onclick="setDefaultMode(1)">EDITOR</button>
                <button onclick="setDefaultMode(2)">WORKSTATION</button>
            </div>
            <p class="export-note">(Click outside to skip)</p>
        </div>
    </div>

    <div id="exportModalBackdrop" class="hidden">
        <div id="exportModalPanel" class="glass-panel">
            <h3>Export / Load</h3>
            <div class="export-options">
                <button id="exportWavBtn">WAV</button><button id="exportMp3Btn">MP3</button><button id="exportOggBtn">OGG</button>
            </div>
            <div class="export-options">
                <button onclick="DAW.saveProject()">JSON</button>
                <button onclick="document.getElementById('jsonLoadInput').click()">LOAD</button>
            </div>
            <button id="closeExportModalBtn">Cancel</button>
            <p class="export-note">Metadata tags are only saved to .mp3<br>(Other formats may not fully save tags)</p>
        </div>
    </div>

    <div id="resetModalBackdrop" class="hidden"><div id="resetModalPanel" class="glass-panel"><h3 id="resetModalTitle">Confirm Reset</h3><p id="resetModalText" style="margin-bottom: 20px;"></p><div class="export-options"><button id="resetConfirmBtn">Reset</button><button id="resetCancelBtn">Cancel</button></div></div></div>

    <div id="effectsModalBackdrop" class="hidden">
        <div id="effectsModalPanel" class="glass-panel">
            <h3>Track Effects</h3>
            
            <div class="control-group" style="flex-direction: row; align-items: center; gap: 10px; margin-top: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 15px;">
                <input type="checkbox" id="fxUseBpm" onchange="DAW.toggleBpmMode()">
                <label for="fxUseBpm" style="margin:0; cursor: pointer;">Enable Fixed BPM / Grid Snap</label>
            </div>
            <div class="control-group hidden" id="fxBpmGroup">
                <label>BPM</label>
                <div class="value-input-group">
                    <input type="range" min="40" max="240" value="120" oninput="document.getElementById('fxBpmInput').value=this.value; DAW.updateSettings()">
                    <input type="number" id="fxBpmInput" value="120" class="value-input" onchange="DAW.updateSettings()">
                </div>
            </div>
            <div class="control-group"><label>Distortion</label><div class="value-input-group"><input type="range" id="fxDistortion" min="0" max="100" step="1" value="0"><input type="number" id="fxDistortionInput" value="0" class="value-input"></div></div>
            <div class="control-group"><label>Bitrate</label><div class="value-input-group"><input type="range" id="fxBitrate" min="1" max="16" step="1" value="16"><input type="number" id="fxBitrateInput" value="16" class="value-input"></div></div>
            <div class="control-group"><label>Reverb</label><div class="value-input-group"><input type="range" id="fxReverb" min="0" max="1" step="0.01" value="0"><input type="number" id="fxReverbInput" value="0" class="value-input"></div></div>
            <div id="fxEqContainer" style="display:flex; gap:5px; margin: 10px 0; justify-content: space-between;"></div>
            <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" id="fxApplyAll"><label for="fxApplyAll" style="margin:0;">Apply to All Tracks</label>
            </div>
            <div class="export-options"><button onclick="DAW.saveEffects()">Save</button><button id="closeEffectsModalBtn">Close</button></div>
        </div>
    </div>

    <div id="addTrackMenu" class="scrollable-menu"></div>
    <div id="trackContextMenu"><button onclick="DAW.ctxRename()">Rename</button><button onclick="DAW.ctxChangeType(event)">Change Type</button><button onclick="DAW.ctxColor(event)">Note Color</button><button onclick="DAW.ctxDelete()">Delete</button></div>
    <div id="gridContextMenu"></div>
    <div id="typeSelectMenu" class="scrollable-menu"></div>
    <input type="color" id="trackColorPicker" class="hidden" onchange="DAW.setTrackColor(this.value)">

    <footer style="z-index: 5; text-align: center; margin-top: 20px; color: #555; padding: 10px; position: relative;"><span id="revealTrigger" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; cursor: pointer; z-index: 15; opacity: 0; pointer-events: none;"></span><a href="https://xetsue.github.io/" target="_blank" rel="noopener noreferrer" id="targetLink" style="color: inherit; text-decoration: none; opacity: 1; pointer-events: auto; transition: opacity 0.5s ease-in-out; z-index: 10;">xetsue.github.io</a></footer>
    <script>document.addEventListener('DOMContentLoaded', function() { const trigger = document.getElementById('revealTrigger'); const link = document.getElementById('targetLink'); const hideLink = () => { link.style.opacity = '0'; link.style.pointerEvents = 'none'; trigger.style.opacity = '1'; trigger.style.pointerEvents = 'auto'; }; setTimeout(hideLink, 1500); trigger.addEventListener('click', function() { link.style.opacity = '1'; link.style.pointerEvents = 'auto'; trigger.style.opacity = '0'; trigger.style.pointerEvents = 'none'; setTimeout(hideLink, 2000); }); });</script>
    
    <script>
        // (Same global variables and setup code)
        let audioContext; let analyser; let animationFrameId = null; let loopMode = 0; const LOOP_SYMBOLS = ['∞', '∞', '∞']; let currentSound = null; let modalContentId = null; let modalOriginalParent = null; let isAdvancedVisible = false;
        let isAudioFileLoaded = false; let audioFileBuffer = null; let originalAudioFileBuffer = null; let audioFileSource = null; let isPlaying = false; let playbackStartTime = 0; let playbackStartOffset = 0; let eqBands = []; let isReversed = false; let loadedFileInfo = {}; let videoElement; let videoObjectUrl = null;
        let mediaRecorder; let recordedChunks = []; let isRecording = false;
        let distortionNode, wetGainNode, dryGainNode, convolverNode, masterGainNode, pannerNode, bitCrusherNode; let currentMode = 0; const MODES = ['SYNTH', 'EDITOR', 'WORKSTATION'];
        const DEFAULTS = { waveType: 'sine', filterType: 'lowpass', startFreq: 1000, endFreq: 1000, audioDuration: 0.7, decayTime: 0.07, attackTime: 0.005, filterFreq: 4000, filterQ: 1.0, sustainLevel: 0.5, releaseTime: 0.1, lfoRate: 5.0, lfoDepth: 0.0, delayTime: 0.3, feedback: 0.0, delayMix: 0.0, distortionAmount: 0, reverbMix: 0.0, masterVolume: 0, };
        const COLLAPSED_DEFAULTS = { sustainLevel: 0.0001, releaseTime: 0.01, lfoDepth: 0.0, delayTime: 0.0, feedback: 0.0, delayMix: 0.0, distortionAmount: 0, reverbMix: 0.0, masterVolume: 0 };
        const WAVE_OPTIONS = ['sine', 'square', 'sawtooth', 'triangle']; const FILTER_OPTIONS = ['lowpass', 'highpass', 'bandpass', 'notch']; const THEMES = ['default', 'light-theme', 'retro-dark-theme', 'retro-light-theme']; const VISUALIZER_TYPES = ['bars', 'line', 'circle', 'wave', 'rings', 'video'];
        let currentThemeIndex = 0; let currentVisualizerIndex = 0; let lastResetClickTime = 0;
        let distortionCurveCache = {};
        
        const createInstr = (id, name) => ({ id, name, cat: 'melodic' });
        const createDrum = (id, name, file) => ({ id, name, file, cat: 'drum' });
        const createLegacy = (name, legacyId) => ({ name, id: legacyId, cat: 'legacy', legacyId: legacyId });

        const INSTRUMENT_LIBRARY = {
            'Piano': [
                createInstr(0, 'Acoustic Grand Piano'), createInstr(1, 'Bright Acoustic Piano'), createInstr(2, 'Electric Grand Piano'), createInstr(3, 'Honky-tonk Piano'),
                createInstr(4, 'Electric Piano 1'), createInstr(5, 'Electric Piano 2'), createInstr(6, 'Harpsichord'), createInstr(7, 'Clavinet')
            ],
            // ... (Rest of instrument library same as before)
            'Chromatic Percussion': [
                createInstr(8, 'Celesta'), createInstr(9, 'Glockenspiel'), createInstr(10, 'Music Box'), createInstr(11, 'Vibraphone'),
                createInstr(12, 'Marimba'), createInstr(13, 'Xylophone'), createInstr(14, 'Tubular Bells'), createInstr(15, 'Dulcimer')
            ],
            'Organ': [
                createInstr(16, 'Drawbar Organ'), createInstr(17, 'Percussive Organ'), createInstr(18, 'Rock Organ'), createInstr(19, 'Church Organ'),
                createInstr(20, 'Reed Organ'), createInstr(21, 'Accordion'), createInstr(22, 'Harmonica'), createInstr(23, 'Tango Accordion')
            ],
            'Guitar': [
                createInstr(24, 'Acoustic Guitar (nylon)'), createInstr(25, 'Acoustic Guitar (steel)'), createInstr(26, 'Electric Guitar (jazz)'), createInstr(27, 'Electric Guitar (clean)'),
                createInstr(28, 'Electric Guitar (muted)'), createInstr(29, 'Overdriven Guitar'), createInstr(30, 'Distortion Guitar'), createInstr(31, 'Guitar Harmonics')
            ],
            'Bass': [
                createInstr(32, 'Acoustic Bass'), createInstr(33, 'Electric Bass (finger)'), createInstr(34, 'Electric Bass (pick)'), createInstr(35, 'Fretless Bass'),
                createInstr(36, 'Slap Bass 1'), createInstr(37, 'Slap Bass 2'), createInstr(38, 'Synth Bass 1'), createInstr(39, 'Synth Bass 2')
            ],
            'Strings': [
                createInstr(40, 'Violin'), createInstr(41, 'Viola'), createInstr(42, 'Cello'), createInstr(43, 'Contrabass'),
                createInstr(44, 'Tremolo Strings'), createInstr(45, 'Pizzicato Strings'), createInstr(46, 'Orchestral Harp'), createInstr(47, 'Timpani')
            ],
            'Ensemble': [
                createInstr(48, 'String Ensemble 1'), createInstr(49, 'String Ensemble 2'), createInstr(50, 'Synth Strings 1'), createInstr(51, 'Synth Strings 2'),
                createInstr(52, 'Choir Aahs'), createInstr(53, 'Voice Oohs'), createInstr(54, 'Synth Choir'), createInstr(55, 'Orchestra Hit')
            ],
            'Brass': [
                createInstr(56, 'Trumpet'), createInstr(57, 'Trombone'), createInstr(58, 'Tuba'), createInstr(59, 'Muted Trumpet'),
                createInstr(60, 'French Horn'), createInstr(61, 'Brass Section'), createInstr(62, 'Synth Brass 1'), createInstr(63, 'Synth Brass 2')
            ],
            'Reed': [
                createInstr(64, 'Soprano Sax'), createInstr(65, 'Alto Sax'), createInstr(66, 'Tenor Sax'), createInstr(67, 'Baritone Sax'),
                createInstr(68, 'Oboe'), createInstr(69, 'English Horn'), createInstr(70, 'Bassoon'), createInstr(71, 'Clarinet')
            ],
            'Pipe': [
                createInstr(72, 'Piccolo'), createInstr(73, 'Flute'), createInstr(74, 'Recorder'), createInstr(75, 'Pan Flute'),
                createInstr(76, 'Blown bottle'), createInstr(77, 'Shakuhachi'), createInstr(78, 'Whistle'), createInstr(79, 'Ocarina')
            ],
            'Synth Lead': [
                createInstr(80, 'Lead 1 (square)'), createInstr(81, 'Lead 2 (sawtooth)'), createInstr(82, 'Lead 3 (calliope)'), createInstr(83, 'Lead 4 (chiff)'),
                createInstr(84, 'Lead 5 (charang)'), createInstr(85, 'Lead 6 (voice)'), createInstr(86, 'Lead 7 (fifths)'), createInstr(87, 'Lead 8 (bass + lead)')
            ],
            'Synth Pad': [
                createInstr(88, 'Pad 1 (new age)'), createInstr(89, 'Pad 2 (warm)'), createInstr(90, 'Pad 3 (polysynth)'), createInstr(91, 'Pad 4 (choir)'),
                createInstr(92, 'Pad 5 (bowed)'), createInstr(93, 'Pad 6 (metallic)'), createInstr(94, 'Pad 7 (halo)'), createInstr(95, 'Pad 8 (sweep)')
            ],
            'Synth Effects': [
                createInstr(96, 'FX 1 (rain)'), createInstr(97, 'FX 2 (soundtrack)'), createInstr(98, 'FX 3 (crystal)'), createInstr(99, 'FX 4 (atmosphere)'),
                createInstr(100, 'FX 5 (brightness)'), createInstr(101, 'FX 6 (goblins)'), createInstr(102, 'FX 7 (echoes)'), createInstr(103, 'FX 8 (sci-fi)')
            ],
            'Ethnic': [
                createInstr(104, 'Sitar'), createInstr(105, 'Banjo'), createInstr(106, 'Shamisen'), createInstr(107, 'Koto'),
                createInstr(108, 'Kalimba'), createInstr(109, 'Bagpipe'), createInstr(110, 'Fiddle'), createInstr(111, 'Shanai')
            ],
            'Percussive (Melodic)': [
                createInstr(112, 'Tinkle Bell'), createInstr(113, 'Agogo'), createInstr(114, 'Steel Drums'), createInstr(115, 'Woodblock'),
                createInstr(116, 'Taiko Drum'), createInstr(117, 'Melodic Tom'), createInstr(118, 'Synth Drum'), createInstr(119, 'Reverse Cymbal')
            ],
            'Sound Effects': [
                createInstr(120, 'Guitar Fret Noise'), createInstr(121, 'Breath Noise'), createInstr(122, 'Seashore'), createInstr(123, 'Bird Tweet'),
                createInstr(124, 'Telephone Ring'), createInstr(125, 'Helicopter'), createInstr(126, 'Applause'), createInstr(127, 'Gunshot')
            ],
            'Drum Kit': [
                createDrum(35, 'Bass Drum 2', '35_16_JCLive_sf2_file'), createDrum(36, 'Bass Drum 1', '36_16_JCLive_sf2_file'), createDrum(37, 'Side Stick', '37_16_JCLive_sf2_file'), createDrum(38, 'Snare Drum 1', '38_16_JCLive_sf2_file'),
                createDrum(39, 'Hand Clap', '39_16_JCLive_sf2_file'), createDrum(40, 'Snare Drum 2', '40_16_JCLive_sf2_file'), createDrum(41, 'Low Tom 2', '41_16_JCLive_sf2_file'), createDrum(42, 'Closed Hi-hat', '42_16_JCLive_sf2_file'),
                createDrum(43, 'Low Tom 1', '43_16_JCLive_sf2_file'), createDrum(44, 'Pedal Hi-hat', '44_16_JCLive_sf2_file'), createDrum(45, 'Mid Tom 2', '45_16_JCLive_sf2_file'), createDrum(46, 'Open Hi-hat', '46_16_JCLive_sf2_file'),
                createDrum(47, 'Mid Tom 1', '47_16_JCLive_sf2_file'), createDrum(48, 'High Tom 2', '48_16_JCLive_sf2_file'), createDrum(49, 'Crash Cymbal 1', '49_16_JCLive_sf2_file'), createDrum(50, 'High Tom 1', '50_16_JCLive_sf2_file'),
                createDrum(51, 'Ride Cymbal 1', '51_16_JCLive_sf2_file'), createDrum(52, 'Chinese Cymbal', '52_16_JCLive_sf2_file'), createDrum(53, 'Ride Bell', '53_16_JCLive_sf2_file'), createDrum(54, 'Tambourine', '54_16_JCLive_sf2_file'),
                createDrum(55, 'Splash Cymbal', '55_16_JCLive_sf2_file'), createDrum(56, 'Cowbell', '56_16_JCLive_sf2_file'), createDrum(57, 'Crash Cymbal 2', '57_16_JCLive_sf2_file'), createDrum(58, 'Vibra Slap', '58_16_JCLive_sf2_file'),
                createDrum(59, 'Ride Cymbal 2', '59_16_JCLive_sf2_file'), createDrum(60, 'High Bongo', '60_16_JCLive_sf2_file'), createDrum(61, 'Low Bongo', '61_16_JCLive_sf2_file'), createDrum(62, 'Mute High Conga', '62_16_JCLive_sf2_file'),
                createDrum(63, 'Open High Conga', '63_16_JCLive_sf2_file'), createDrum(64, 'Low Conga', '64_16_JCLive_sf2_file'), createDrum(65, 'High Timbale', '65_16_JCLive_sf2_file'), createDrum(66, 'Low Timbale', '66_16_JCLive_sf2_file'),
                createDrum(67, 'High Agogo', '67_16_JCLive_sf2_file'), createDrum(68, 'Low Agogo', '68_16_JCLive_sf2_file'), createDrum(69, 'Cabasa', '69_16_JCLive_sf2_file'), createDrum(70, 'Maracas', '70_16_JCLive_sf2_file'),
                createDrum(71, 'Short Whistle', '71_16_JCLive_sf2_file'), createDrum(72, 'Long Whistle', '72_16_JCLive_sf2_file'), createDrum(73, 'Short Guiro', '73_16_JCLive_sf2_file'), createDrum(74, 'Long Guiro', '74_16_JCLive_sf2_file'),
                createDrum(75, 'Claves', '75_16_JCLive_sf2_file'), createDrum(76, 'High Wood Block', '76_16_JCLive_sf2_file'), createDrum(77, 'Low Wood Block', '77_16_JCLive_sf2_file'), createDrum(78, 'Mute Cuica', '78_16_JCLive_sf2_file'),
                createDrum(79, 'Open Cuica', '79_16_JCLive_sf2_file'), createDrum(80, 'Mute Triangle', '80_16_JCLive_sf2_file'), createDrum(81, 'Open Triangle', '81_16_JCLive_sf2_file')
            ],
            'Legacy': [
                createLegacy('Piano', 'piano'),
                createLegacy('Bell', 'bell'),
                createLegacy('Pad', 'pad'),
                createLegacy('8-bit', '8bit')
            ]
        };
        // (Helper functions from before)
        function getInstrumentData(category, name) {
            
            if (category === 'Legacy') {
                const item = INSTRUMENT_LIBRARY['Legacy'].find(i => i.name === name);
                if(item) return { name: name, cat: 'legacy', legacyId: item.legacyId };
            }

            
            if (category === 'Drum Kit') {
                 const item = INSTRUMENT_LIBRARY['Drum Kit'].find(i => i.name === name);
                 if(item) {
                     const id = item.id;
                     return { 
                         name: name, 
                         var: `_drum_${id}_0_FluidR3_GM_sf2_file`, 
                         file: `128${id}_0_FluidR3_GM_sf2_file.js`, 
                         cat: 'drum' 
                     };
                 }
                 return null;
            }

            let item = INSTRUMENT_LIBRARY[category] ? INSTRUMENT_LIBRARY[category].find(i => i.name === name) : null;
            if(!item) return null;

            
            const padded = (item.id * 10).toString().padStart(4, '0');
            return { name: name, var: `_tone_${padded}_GeneralUserGS_sf2_file`, file: `${padded}_GeneralUserGS_sf2_file.js`, cat: 'melodic' };
        }

        function initSelects() { const waveSelect = document.getElementById('waveType'); const filterSelect = document.getElementById('filterType'); WAVE_OPTIONS.forEach(opt => waveSelect.options.add(new Option(opt.charAt(0).toUpperCase() + opt.slice(1), opt))); FILTER_OPTIONS.forEach(opt => filterSelect.options.add(new Option(opt.charAt(0).toUpperCase() + opt.slice(1), opt))); }
        function setupEqualizer() { const eqContainer = document.getElementById('equalizerContainer'); eqContainer.innerHTML = ''; const frequencies = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000]; const tooltips = ["Exteme-Low-Bass (Rumble)", "Center of Bass", "Low-end Mid (Vocal/Instruments)", "Low-mid Focal (Electric/Vocal/Box)", "Center Mid (Rhythm/Nasal)", "High Mid (Harmonics/Orchestral)", "Low-end High (Clarity/ [S-T] Noise)", "Core High-end (Air/Echo)", "Highest Range (Overtone/Sharp)"]; frequencies.forEach((freq, i) => { const bandDiv = document.createElement('div'); bandDiv.className = 'eq-band'; const label = document.createElement('span'); label.textContent = (freq < 1000 ? freq : (freq/1000) + 'k') + 'Hz'; const slider = document.createElement('input'); slider.type = 'range'; slider.min = -20; slider.max = 20; slider.step = 0.1; slider.value = 0; slider.className = 'vertical'; slider.dataset.index = i; slider.oninput = (e) => { if(eqBands[i]) eqBands[i].gain.value = parseFloat(e.target.value); }; const tooltip = document.createElement('span'); tooltip.className = 'tooltip'; tooltip.textContent = tooltips[i]; bandDiv.appendChild(label); bandDiv.appendChild(slider); bandDiv.appendChild(tooltip); eqContainer.appendChild(bandDiv); }); }

        document.addEventListener('DOMContentLoaded', () => {
            initSelects(); setupEqualizer(); videoElement = document.getElementById('videoVisualizer'); isAdvancedVisible = localStorage.getItem('synthAdvancedVisible') === 'true'; const advancedContainer = document.getElementById('advancedControlsContainer'); const arrow = document.querySelector('#advancedToggle .arrow'); if(isAdvancedVisible){ advancedContainer.style.display = 'grid'; if(arrow) arrow.style.transform = 'rotate(180deg)'; } else { advancedContainer.style.display = 'none'; if(arrow) arrow.style.transform = 'rotate(0deg)'; } document.getElementById('advancedToggle').addEventListener('click', toggleAdvancedControls); loadSettings(); generateCode(); const sideButtons = document.getElementById('sideButtons'); sideButtons.classList.add(localStorage.getItem('synthButtonSide') || 'left'); currentVisualizerIndex = VISUALIZER_TYPES.indexOf(localStorage.getItem('synthVisualizerType') || 'bars'); if (currentVisualizerIndex === -1) currentVisualizerIndex = 0; drawBlankVisualizer();
            document.getElementById('leftCornerBtn').addEventListener('click', () => { if (sideButtons.classList.contains('right')) toggleButtonSide('left'); }); document.getElementById('rightCornerBtn').addEventListener('click', () => { if (sideButtons.classList.contains('left')) toggleButtonSide('right'); }); document.getElementById('globalTitle').addEventListener('click', cycleMode); loopMode = parseInt(localStorage.getItem('synthLoopMode') || '0', 10); updateLoopButton(); currentThemeIndex = THEMES.indexOf(localStorage.getItem('synthTheme') || 'default'); if (currentThemeIndex === -1) currentThemeIndex = 0; if (THEMES[currentThemeIndex] !== 'default') document.body.classList.add(THEMES[currentThemeIndex]); if (window.innerWidth >= 769) document.getElementById('scrollableControls').appendChild(document.getElementById('codeOutputContainer')); else document.querySelector('.controls-group-right').appendChild(document.getElementById('codeOutputContainer'));
            const visualizerContainer = document.getElementById('visualizer-container'); visualizerContainer.addEventListener('click', () => { if (currentMode !== 2) document.getElementById('audioFileInput').click(); }); visualizerContainer.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); visualizerContainer.classList.add('dragover'); }); visualizerContainer.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); visualizerContainer.classList.remove('dragover'); }); visualizerContainer.addEventListener('drop', (e) => { e.preventDefault(); e.stopPropagation(); visualizerContainer.classList.remove('dragover'); const file = e.dataTransfer.files[0]; if (file) { if (file.name.endsWith('.json')) { const reader = new FileReader(); reader.onload = (ev) => DAW.loadProject(ev.target.result); reader.readAsText(file); } else loadAudioFile(file); } }); document.getElementById('audioFileInput').addEventListener('change', (e) => { const file = e.target.files[0]; if (file) loadAudioFile(file); }); videoElement.addEventListener('click', () => { if (videoElement.requestFullscreen) videoElement.requestFullscreen(); else if (videoElement.webkitRequestFullscreen) videoElement.webkitRequestFullscreen(); });
            const linkRate = (id1, id2) => { document.getElementById(id1).addEventListener('input', (e) => { document.getElementById(id2).value = e.target.value; const r = parseFloat(e.target.value); if(audioFileSource) audioFileSource.playbackRate.value = r; if(videoElement.src) videoElement.playbackRate = r; }); }; linkRate('playbackRate', 'playbackRateInput'); linkRate('playbackRateInput', 'playbackRate');
            document.getElementById('reverseBtn').addEventListener('click', reverseAudio); document.getElementById('coverArt').addEventListener('click', () => document.getElementById('coverArtInput').click()); document.getElementById('coverArtInput').addEventListener('change', (e) => { const f = e.target.files[0]; if(f) { const r = new FileReader(); r.onload = (ev) => document.getElementById('coverArt').src = ev.target.result; r.readAsDataURL(f); }}); document.addEventListener('keydown', handleKeyboardShortcuts); document.addEventListener('keyup', handleKeyboardShortcuts);
            const linkEf = (id1, id2, fn) => { document.getElementById(id1).addEventListener('input', (e) => { document.getElementById(id2).value = e.target.value; fn(parseFloat(e.target.value)); }); }; linkEf('editorDistortion', 'editorDistortionInput', (v) => { if (distortionNode) distortionNode.curve = makeDistortionCurve(v); }); linkEf('editorDistortionInput', 'editorDistortion', (v) => { if (distortionNode) distortionNode.curve = makeDistortionCurve(v); }); linkEf('editorReverb', 'editorReverbInput', (v) => { if (wetGainNode) { wetGainNode.gain.setValueAtTime(v, audioContext.currentTime); dryGainNode.gain.setValueAtTime(1-v, audioContext.currentTime); }}); linkEf('editorReverbInput', 'editorReverb', (v) => { if (wetGainNode) { wetGainNode.gain.setValueAtTime(v, audioContext.currentTime); dryGainNode.gain.setValueAtTime(1-v, audioContext.currentTime); }}); linkEf('editorPan', 'editorPanInput', (v) => { if(pannerNode) pannerNode.pan.setValueAtTime(v, audioContext.currentTime); }); linkEf('editorPanInput', 'editorPan', (v) => { if(pannerNode) pannerNode.pan.setValueAtTime(v, audioContext.currentTime); });
            const linkBit = (id1, id2, fn) => { document.getElementById(id1).addEventListener('input', (e) => { document.getElementById(id2).value = e.target.value; fn(parseFloat(e.target.value)); }); }; linkBit('editorBitrate', 'editorBitrateInput', (v) => { if (bitCrusherNode) bitCrusherNode.curve = makeBitCrusherCurve(v); }); linkBit('editorBitrateInput', 'editorBitrate', (v) => { if (bitCrusherNode) bitCrusherNode.curve = makeBitCrusherCurve(v); });
            const setVol = (v) => { ['masterVolume','masterVolumeInput','editorVolume','editorVolumeInput'].forEach(id => document.getElementById(id).value = v); if(masterGainNode) masterGainNode.gain.setValueAtTime(Math.pow(10, parseFloat(v) / 20), audioContext.currentTime); }; ['masterVolume','masterVolumeInput','editorVolume','editorVolumeInput'].forEach(id => document.getElementById(id).addEventListener('input', (e) => setVol(e.target.value)));
            document.getElementById('exportWavBtn').addEventListener('click', () => startExport('wav')); document.getElementById('exportMp3Btn').addEventListener('click', () => startExport('mp3')); document.getElementById('exportOggBtn').addEventListener('click', () => startExport('ogg')); document.getElementById('closeExportModalBtn').addEventListener('click', hideExportModal); document.getElementById('exportModalBackdrop').addEventListener('click', (e) => { if (e.target.id === 'exportModalBackdrop') hideExportModal(); }); document.getElementById('resetConfirmBtn').addEventListener('click', handleResetConfirm); document.getElementById('resetCancelBtn').addEventListener('click', hideResetModal); document.getElementById('resetModalBackdrop').addEventListener('click', (e) => { if (e.target.id === 'resetModalBackdrop') hideResetModal(); });
            document.getElementById('fxDistortion').addEventListener('input', e => document.getElementById('fxDistortionInput').value = e.target.value); document.getElementById('fxDistortionInput').addEventListener('input', e => document.getElementById('fxDistortion').value = e.target.value); 
            document.getElementById('fxBitrate').addEventListener('input', e => document.getElementById('fxBitrateInput').value = e.target.value); document.getElementById('fxBitrateInput').addEventListener('input', e => document.getElementById('fxBitrate').value = e.target.value);
            document.getElementById('fxReverb').addEventListener('input', e => document.getElementById('fxReverbInput').value = e.target.value); document.getElementById('fxReverbInput').addEventListener('input', e => document.getElementById('fxReverb').value = e.target.value);
            document.getElementById('closeEffectsModalBtn').addEventListener('click', () => { const m = document.getElementById('effectsModalBackdrop'); m.classList.remove('visible'); setTimeout(() => m.classList.add('hidden'), 300); });
            document.getElementById('jsonLoadInput').addEventListener('change', (e) => { const f = e.target.files[0]; if(f) { const r = new FileReader(); r.onload = (ev) => DAW.loadProject(ev.target.result); r.readAsText(f); } hideExportModal(); });
            const pb = document.getElementById('progressBarContainer'); let isSeeking = false; const handleSeek = (e) => { if (!audioFileBuffer) return; const rect = pb.getBoundingClientRect(); const x = (e.clientX || e.touches[0].clientX) - rect.left; const t = (Math.max(0, Math.min(1, x / rect.width))) * audioFileBuffer.duration; document.getElementById('progressBar').style.width = `${(t/audioFileBuffer.duration)*100}%`; playbackStartOffset = t; if (videoElement.src) videoElement.currentTime = t; if (isPlaying) { if (audioFileSource) { audioFileSource.onended = null; try { audioFileSource.stop(); } catch(err) {} } playAudioFile(t); } }; pb.addEventListener('mousedown', (e) => { isSeeking = true; handleSeek(e); }); pb.addEventListener('touchstart', (e) => { isSeeking = true; handleSeek(e); }, { passive: true }); window.addEventListener('mousemove', (e) => { if (isSeeking) handleSeek(e); }); window.addEventListener('touchmove', (e) => { if (isSeeking) handleSeek(e); }, { passive: true }); window.addEventListener('mouseup', () => isSeeking = false); window.addEventListener('touchend', () => isSeeking = false);
            document.getElementById('startModalBackdrop').addEventListener('click', (e) => { if(e.target.id === 'startModalBackdrop') { document.getElementById('startModalBackdrop').classList.remove('visible'); setTimeout(() => document.getElementById('startModalBackdrop').classList.add('hidden'), 300); } });
            
            const dpad = document.getElementById('dpadContainer');
            const dragBtn = document.getElementById('dpadDragBtn');
            let isDraggingDpad = false;
            let dpadOffsetX, dpadOffsetY;

            const startDpadDrag = (clientX, clientY) => {
                const rect = dpad.getBoundingClientRect();
                dpadOffsetX = clientX - rect.left;
                dpadOffsetY = clientY - rect.top;
                isDraggingDpad = true;
            };

            dragBtn.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); startDpadDrag(e.clientX, e.clientY); });
            dragBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); startDpadDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});

            const moveDpad = (clientX, clientY) => {
                if (!isDraggingDpad) return;
                dpad.style.left = (clientX - dpadOffsetX) + 'px';
                dpad.style.top = (clientY - dpadOffsetY) + 'px';
                dpad.style.bottom = 'auto'; dpad.style.right = 'auto';
            };

            window.addEventListener('mousemove', (e) => moveDpad(e.clientX, e.clientY));
            window.addEventListener('touchmove', (e) => { if(isDraggingDpad) { e.preventDefault(); moveDpad(e.touches[0].clientX, e.touches[0].clientY); }}, {passive: false});
            window.addEventListener('mouseup', () => isDraggingDpad = false);
            window.addEventListener('touchend', () => isDraggingDpad = false);

            DAW.init();
            
            const savedDefaultMode = localStorage.getItem('synthDefaultMode');
            if(savedDefaultMode !== null) {
                currentMode = parseInt(savedDefaultMode);
                updateModeUI();
            } else {
                const m = document.getElementById('startModalBackdrop'); m.classList.remove('hidden'); setTimeout(()=>m.classList.add('visible'), 10);
            }
        });
        
        // (Other global functions: setDefaultMode, cycleMode, updateModeUI, toggleAdvancedControls, etc... same as before)
        function setDefaultMode(m) {
            localStorage.setItem('synthDefaultMode', m);
            currentMode = m;
            updateModeUI();
            const mEl = document.getElementById('startModalBackdrop'); mEl.classList.remove('visible'); setTimeout(()=>mEl.classList.add('hidden'), 300);
        }

        function cycleMode() { currentMode = (currentMode + 1) % 3; updateModeUI(); }
        function updateModeUI() { 
            const titles = ['./SYNTH.', './EDITOR.', './WORKSTATION.']; 
            document.getElementById('globalTitle').textContent = titles[currentMode]; 
            document.getElementById('synthLayout').classList.toggle('hidden', currentMode === 2); 
            document.getElementById('workstationContainer').classList.toggle('hidden', currentMode !== 2); 
            document.getElementById('mobile-fixed-buttons').classList.toggle('hidden', currentMode === 2); 
            
            const showRec = (currentMode === 1);
            document.getElementById('recBtn').classList.toggle('hidden', !showRec);
            document.getElementById('mobRecBtn').classList.toggle('hidden', !showRec);

            if (currentMode === 0) toggleAudioEditorMode(false); 
            else if (currentMode === 1) toggleAudioEditorMode(true, loadedFileInfo.type || ''); 
            if (currentMode === 2) { DAW.resize(); stopCurrentSound(); } 
        }
        function toggleAdvancedControls() { const c = document.getElementById('advancedControlsContainer'); const a = document.querySelector('#advancedToggle .arrow'); isAdvancedVisible = !isAdvancedVisible; c.style.display = isAdvancedVisible ? 'grid' : 'none'; a.style.transform = isAdvancedVisible ? 'rotate(180deg)' : 'rotate(0deg)'; localStorage.setItem('synthAdvancedVisible', isAdvancedVisible); generateCode(); if (loopMode > 0 && !isAudioFileLoaded) playCustomSound(); }
        function shuffleVisualizer() { currentVisualizerIndex = (currentVisualizerIndex + 1) % VISUALIZER_TYPES.length; if (VISUALIZER_TYPES[currentVisualizerIndex] === 'video' && !videoElement.src) currentVisualizerIndex = (currentVisualizerIndex + 1) % VISUALIZER_TYPES.length; localStorage.setItem('synthVisualizerType', VISUALIZER_TYPES[currentVisualizerIndex]); if (!currentSound && !audioFileSource) drawBlankVisualizer(); const ind = document.getElementById('visualizer-indicator'); ind.textContent = VISUALIZER_TYPES[currentVisualizerIndex].charAt(0).toUpperCase() + VISUALIZER_TYPES[currentVisualizerIndex].slice(1); ind.style.opacity = '1'; setTimeout(() => { ind.style.opacity = '0'; }, 1500); }
        function drawBlankVisualizer() { const c = document.getElementById('visualizer'); const cc = c.getContext('2d'); c.width = c.offsetWidth; c.height = c.offsetHeight; cc.fillStyle = getComputedStyle(document.body).getPropertyValue('--code-bg-color'); cc.fillRect(0, 0, c.width, c.height); }
        async function createReverb(ctx) { const l = ctx.sampleRate * 2; const b = ctx.createBuffer(2, l, ctx.sampleRate); for (let i = 0; i < l; i++) { const d = Math.pow((l-i)/l, 2); b.getChannelData(0)[i] = (Math.random()*2-1)*d; b.getChannelData(1)[i] = (Math.random()*2-1)*d; } const c = ctx.createConvolver(); c.buffer = b; return c; }
        async function initContext() { if (!audioContext) { audioContext = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' }); analyser = audioContext.createAnalyser(); convolverNode = await createReverb(audioContext); masterGainNode = audioContext.createGain(); masterGainNode.gain.value = Math.pow(10, parseFloat(document.getElementById(isAudioFileLoaded?'editorVolume':'masterVolume').value) / 20); analyser.connect(masterGainNode); masterGainNode.connect(audioContext.destination); } if (audioContext.state === 'suspended') audioContext.resume(); }
        function linkSlider(s) { document.getElementById(s.dataset.link).value = s.value; saveSettings(); }
        function linkInput(i) { document.getElementById(i.dataset.link).value = i.value; saveSettings(); }
        function openModalFor(id) { if (window.innerWidth <= 768) { const b = document.getElementById('codeModalBackdrop'); const p = document.getElementById('codeModalPanel'); const c = document.getElementById(id); if (c.parentElement !== p) { modalOriginalParent = c.parentElement; modalContentId = id; p.appendChild(c); } c.style.display = 'block'; b.classList.remove('hidden'); b.classList.add('visible'); b.addEventListener('click', closeModalOutside); } }
        function closeModalOutside(e) { if (e.target === document.getElementById('codeModalBackdrop')) closeModal(); }
        function closeModal() { const b = document.getElementById('codeModalBackdrop'); if (modalContentId) { modalOriginalParent.appendChild(document.getElementById(modalContentId)); } b.classList.remove('visible'); b.classList.add('hidden'); b.removeEventListener('click', closeModalOutside); modalContentId = null; }
        function stopCurrentSound() { 
            if (currentSound && currentSound.osc) { 
                try { 
                    const t = audioContext.currentTime; 
                    currentSound.osc.onended = null; 
                    currentSound.gain.gain.cancelScheduledValues(t); 
                    currentSound.gain.gain.setValueAtTime(currentSound.gain.gain.value, t); 
                    currentSound.gain.gain.linearRampToValueAtTime(0.0001, t + 0.05); 
                    currentSound.osc.stop(t + 0.05); 
                    if(currentSound.lfo) currentSound.lfo.stop(t + 0.05); 
                    setTimeout(() => {
                        if(currentSound.osc) currentSound.osc.disconnect();
                        if(currentSound.gain) currentSound.gain.disconnect();
                        if(currentSound.filter) currentSound.filter.disconnect();
                    }, 100);
                } catch (e) {} 
            } 
            if(audioFileSource) { 
                audioFileSource.onended = null; 
                try { audioFileSource.stop(); } catch(e) {} 
                audioFileSource.disconnect(); 
                audioFileSource = null; 
            } 
            if (videoElement.src) videoElement.pause(); 
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } 
            currentSound = null; isPlaying = false; 
            if (isAudioFileLoaded) document.getElementById('reverseBtn').disabled = false; 
            drawBlankVisualizer(); 
        }
        function updateLoopButton() { 
            const btn1 = document.getElementById('loopBtn');
            const btn2 = document.getElementById('mobLoopBtn');
            [btn1, btn2].forEach(btn => { 
                if(isAudioFileLoaded) { 
                    btn.innerHTML = `<b>∞</b>`; 
                    btn.classList.toggle('active', loopMode > 0); 
                    btn.classList.remove('alt'); 
                } else { 
                    btn.innerHTML = `<b>${LOOP_SYMBOLS[loopMode]}</b>`; 
                    btn.classList.toggle('active', loopMode > 0); 
                    btn.classList.toggle('alt', loopMode === 2); 
                } 
            }); 
            if(!isAudioFileLoaded) {
                document.getElementById('playBtn').disabled = loopMode > 0;
                document.getElementById('mobPlayBtn').disabled = loopMode > 0;
            }
            localStorage.setItem('synthLoopMode', loopMode); 
        }
        function toggleLoop() { if(isAudioFileLoaded) { loopMode = loopMode === 0 ? 1 : 0; if(audioFileSource) audioFileSource.loop = loopMode > 0; if(videoElement.src) videoElement.loop = loopMode > 0; } else { stopCurrentSound(); loopMode = (loopMode + 1) % 3; if (loopMode > 0) playCustomSound(); } updateLoopButton(); }
        function applyADSR(g, s, t, d) { g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.5, t + s.attackTime); g.gain.linearRampToValueAtTime(s.sustainLevel, t + s.attackTime + s.decayTime); const r = t + d; const e = r + s.releaseTime; g.gain.setValueAtTime(s.sustainLevel, r); g.gain.linearRampToValueAtTime(0.0001, e); return e; }
        function makeDistortionCurve(k) { 
            if (!k) return null; 
            if(distortionCurveCache[k]) return distortionCurveCache[k];
            const n = 44100; const c = new Float32Array(n); const d = Math.PI / 180; for (let i = 0; i < n; ++i) { const x = i * 2 / n - 1; c[i] = (3 + k) * x * 20 * d / (Math.PI + k * Math.abs(x)); } 
            distortionCurveCache[k] = c;
            return c; 
        }
        function makeBitCrusherCurve(bits) { if (bits >= 16) return null; const n = 44100; const c = new Float32Array(n); const step = 1 / Math.pow(2, bits - 1); for (let i = 0; i < n; ++i) { const x = i * 2 / n - 1; c[i] = Math.round(x / step) * step; } return c; }
        async function playCustomSound() { if(isAudioFileLoaded) { toggleAudioPlayback(); return; } stopCurrentSound(); if (loopMode === 0) { document.getElementById('playBtn').disabled = true; document.getElementById('mobPlayBtn').disabled = true; } await initContext(); const t = audioContext.currentTime; const s = getSettingsFromUI(); const o = audioContext.createOscillator(); const f = audioContext.createBiquadFilter(); const g = audioContext.createGain(); let l = null, n = g; if (s.delayMix > 0) { const d = audioContext.createDelay(1); const df = audioContext.createGain(); const w = audioContext.createGain(); const dr = audioContext.createGain(); const m = audioContext.createGain(); d.delayTime.value = s.delayTime; df.gain.value = s.feedback; w.gain.value = s.delayMix; dr.gain.value = 1-s.delayMix; n.connect(d); d.connect(df); df.connect(d); n.connect(dr); d.connect(w); dr.connect(m); w.connect(m); n = m; } distortionNode = audioContext.createWaveShaper(); distortionNode.curve = makeDistortionCurve(s.distortionAmount); distortionNode.oversample = '4x'; wetGainNode = audioContext.createGain(); dryGainNode = audioContext.createGain(); wetGainNode.gain.value = s.reverbMix; dryGainNode.gain.value = 1-s.reverbMix; n.connect(distortionNode); distortionNode.connect(dryGainNode); distortionNode.connect(wetGainNode); wetGainNode.connect(convolverNode); dryGainNode.connect(analyser); convolverNode.connect(analyser); o.type = s.waveType; f.type = s.filterType; if (s.lfoDepth > 0) { l = audioContext.createOscillator(); l.type = 'sine'; l.frequency.value = s.lfoRate; const lg = audioContext.createGain(); lg.gain.value = s.lfoDepth; l.connect(lg); lg.connect(o.frequency); l.start(t); } o.connect(f); f.connect(g); f.frequency.value = s.filterFreq; f.Q.value = s.filterQ; o.frequency.value = s.startFreq; if (loopMode === 2) { o.loop = true; o.frequency.linearRampToValueAtTime(s.endFreq, t + s.audioDuration); g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.5, t + s.attackTime); g.gain.linearRampToValueAtTime(s.sustainLevel, t + s.attackTime + s.decayTime); o.start(t); } else { o.frequency.linearRampToValueAtTime(s.endFreq, t + s.audioDuration); const e = applyADSR(g, s, t, s.audioDuration); o.start(t); o.stop(e + 0.05); o.onended = () => { if (loopMode === 1 && isPlaying) playCustomSound(); else { document.getElementById('playBtn').disabled = false; document.getElementById('mobPlayBtn').disabled = false; stopCurrentSound(); } }; } currentSound = { osc: o, filter: f, gain: g, lfo: l }; isPlaying = true; visualize(); }
        function getSettingsFromUI() { const s = { waveType: document.getElementById('waveType').value, filterType: document.getElementById('filterType').value, startFreq: parseFloat(document.getElementById('startFreqInput').value), endFreq: parseFloat(document.getElementById('endFreqInput').value), audioDuration: parseFloat(document.getElementById('audioDurationInput').value), decayTime: parseFloat(document.getElementById('decayTimeInput').value), attackTime: parseFloat(document.getElementById('attackTimeInput').value), filterFreq: parseFloat(document.getElementById('filterFreqInput').value), filterQ: parseFloat(document.getElementById('filterQInput').value), sustainLevel: parseFloat(document.getElementById('sustainLevelInput').value) }; if (isAdvancedVisible) { s.releaseTime = parseFloat(document.getElementById('releaseTimeInput').value); s.lfoRate = parseFloat(document.getElementById('lfoRateInput').value); s.lfoDepth = parseFloat(document.getElementById('lfoDepthInput').value); s.delayTime = parseFloat(document.getElementById('delayTimeInput').value); s.feedback = parseFloat(document.getElementById('feedbackInput').value); s.delayMix = parseFloat(document.getElementById('delayMixInput').value); s.distortionAmount = parseFloat(document.getElementById('distortionAmountInput').value); s.reverbMix = parseFloat(document.getElementById('reverbMixInput').value); s.masterVolume = parseFloat(document.getElementById('masterVolumeInput').value); } else Object.assign(s, COLLAPSED_DEFAULTS); return s; }
        function bufferToWav(buffer, opt, metadata) { const numChannels = buffer.numberOfChannels, sampleRate = buffer.sampleRate, format = opt.float32 ? 3 : 1, bitDepth = format === 3 ? 32 : 16; let result; if (numChannels === 2) result = interleave(buffer.getChannelData(0), buffer.getChannelData(1)); else result = buffer.getChannelData(0); return encodeWAV(result, format, sampleRate, numChannels, bitDepth, metadata); }
        function encodeWAV(samples, format, sampleRate, numChannels, bitDepth, metadata) { const bytesPerSample = bitDepth / 8, blockAlign = numChannels * bytesPerSample, dataSize = samples.length * bytesPerSample; const buffer = new ArrayBuffer(44 + dataSize); const view = new DataView(buffer); const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); }; writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); writeString(view, 8, 'WAVE'); writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, format, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * blockAlign, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitDepth, true); writeString(view, 36, 'data'); view.setUint32(40, dataSize, true); if (format === 1) floatTo16BitPCM(view, 44, samples); else writeFloat32(view, 44, samples); return view; }
        function interleave(L, R) { const len = L.length + R.length, res = new Float32Array(len); let i = 0, k = 0; while (i < len) { res[i++] = L[k]; res[i++] = R[k++]; } return res; }
        function writeFloat32(o, off, inp) { for (let i = 0; i < inp.length; i++, off += 4) o.setFloat32(off, inp[i], true); }
        function floatTo16BitPCM(o, off, inp) { for (let i = 0; i < inp.length; i++, off += 2) { const s = Math.max(-1, Math.min(1, inp[i])); o.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true); } }
        function showExportModal() { const m = document.getElementById('exportModalBackdrop'); m.classList.remove('hidden'); setTimeout(() => m.classList.add('visible'), 10); }
        function hideExportModal() { const m = document.getElementById('exportModalBackdrop'); m.classList.remove('visible'); setTimeout(() => m.classList.add('hidden'), 300); }
        async function exportButtonAction(e) { e.stopPropagation(); showExportModal(); }
        async function startExport(format) { hideExportModal(); const btn = document.getElementById('exportBtn'); const originalText = btn.textContent; btn.textContent = '…'; btn.disabled = true; try { if (currentMode === 2) await DAW.export(format); else if (isAudioFileLoaded && audioFileBuffer) await exportEditedAudio(format); else if (!isAudioFileLoaded) await exportSynthAudio(format); else alert("No audio data to export."); } catch(err) { console.error(err); alert('Export failed.'); } finally { btn.textContent = originalText; btn.disabled = false; } }
        function downloadBlob(blob, filename) { const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); }
        function audioBufferToMp3(b) { if (typeof lamejs === 'undefined') throw new Error('lamejs missing'); const enc = new lamejs.Mp3Encoder(b.numberOfChannels, b.sampleRate, 128); const d = []; const c = (f) => { const r = new Int16Array(f.length); for(let i=0; i<f.length; i++) { let s = Math.max(-1, Math.min(1, f[i])); r[i] = s < 0 ? s * 0x8000 : s * 0x7FFF; } return r; }; const l = c(b.getChannelData(0)); const r = b.numberOfChannels > 1 ? c(b.getChannelData(1)) : null; for (let i = 0; i < l.length; i += 1152) { const lc = l.subarray(i, i + 1152); d.push(r ? enc.encodeBuffer(lc, r.subarray(i, i + 1152)) : enc.encodeBuffer(lc)); } d.push(enc.flush()); return new Blob(d, { type: 'audio/mp3' }); }
        async function audioBufferToOgg(b, m) { if (typeof OggVorbisEncoder === 'undefined') throw new Error('Ogg missing'); const enc = new OggVorbisEncoder(b.sampleRate, b.numberOfChannels, 0.6, []); const ch = []; for (let i = 0; i < b.numberOfChannels; i++) ch.push(b.getChannelData(i)); for (let i = 0; i < b.length; i += 4096) { const c = []; for (let j = 0; j < b.numberOfChannels; j++) c.push(ch[j].subarray(i, i + 4096)); enc.encode(c); } return enc.finish('audio/ogg'); }
        async function exportSynthAudio(format) { const s = getSettingsFromUI(); const dur = s.audioDuration + s.releaseTime + 0.05; const ctx = new OfflineAudioContext(1, 44100 * dur, 44100); const osc = ctx.createOscillator(); const f = ctx.createBiquadFilter(); const g = ctx.createGain(); const fg = ctx.createGain(); fg.gain.value = Math.pow(10, s.masterVolume / 20); let n = g; if(s.delayMix > 0) { const d = ctx.createDelay(1), df = ctx.createGain(), w = ctx.createGain(), dr = ctx.createGain(), m = ctx.createGain(); d.delayTime.value = s.delayTime; df.gain.value = s.feedback; w.gain.value = s.delayMix; dr.gain.value = 1-s.delayMix; n.connect(d); d.connect(df); df.connect(d); n.connect(dr); d.connect(w); dr.connect(m); w.connect(m); n = m; } const ds = ctx.createWaveShaper(); ds.curve = makeDistortionCurve(s.distortionAmount); ds.oversample = '4x'; n.connect(ds); let ln = ds; if (s.reverbMix > 0) { const r = await createReverb(ctx), wg = ctx.createGain(), dg = ctx.createGain(), m = ctx.createGain(); wg.gain.value = s.reverbMix; dg.gain.value = 1-s.reverbMix; ds.connect(dg); ds.connect(wg); wg.connect(r); dg.connect(m); r.connect(m); ln = m; } ln.connect(fg); fg.connect(ctx.destination); osc.type = s.waveType; f.type = s.filterType; f.frequency.value = s.filterFreq; f.Q.value = s.filterQ; osc.frequency.value = s.startFreq; osc.frequency.linearRampToValueAtTime(s.endFreq, 0 + s.audioDuration); if (s.lfoDepth > 0) { const l = ctx.createOscillator(); l.type = 'sine'; l.frequency.value = s.lfoRate; const lg = ctx.createGain(); lg.gain.value = s.lfoDepth; l.connect(lg); lg.connect(osc.frequency); l.start(0); } osc.connect(f); f.connect(g); applyADSR(g, s, 0, s.audioDuration); osc.start(0); osc.stop(dur); const b = await ctx.startRendering(); if (format === 'wav') downloadBlob(new Blob([bufferToWav(b, {}, {})], { type: 'audio/wav' }), 'synth.wav'); else if (format === 'mp3') downloadBlob(audioBufferToMp3(b), 'synth.mp3'); else if (format === 'ogg') downloadBlob(await audioBufferToOgg(b, {}), 'synth.ogg'); }
        async function exportEditedAudio(format) { if (!audioFileBuffer) return; const ctx = new OfflineAudioContext(audioFileBuffer.numberOfChannels, audioFileBuffer.length, audioFileBuffer.sampleRate); const src = ctx.createBufferSource(); src.buffer = audioFileBuffer; src.playbackRate.value = parseFloat(document.getElementById('playbackRate').value); const fg = ctx.createGain(); fg.gain.value = Math.pow(10, parseFloat(document.getElementById('editorVolume').value) / 20); let n = src; const freqs = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000]; const sld = document.querySelectorAll('#equalizerContainer input'); freqs.forEach((f, i) => { const eq = ctx.createBiquadFilter(); eq.type = i===0?'lowshelf':i===freqs.length-1?'highshelf':'peaking'; eq.frequency.value = f; eq.gain.value = parseFloat(sld[i].value); n.connect(eq); n = eq; }); const ds = ctx.createWaveShaper(); ds.curve = makeDistortionCurve(parseFloat(document.getElementById('editorDistortion').value)); ds.oversample = '4x'; n.connect(ds); n = ds; const bc = ctx.createWaveShaper(); bc.curve = makeBitCrusherCurve(parseFloat(document.getElementById('editorBitrate').value)); bc.oversample = 'none'; n.connect(bc); n = bc; const rv = parseFloat(document.getElementById('editorReverb').value); if (rv > 0) { const r = await createReverb(ctx), wg = ctx.createGain(), dg = ctx.createGain(), m = ctx.createGain(); wg.gain.value = rv; dg.gain.value = 1-rv; n.connect(dg); n.connect(wg); wg.connect(r); dg.connect(m); r.connect(m); n = m; } if (ctx.destination.channelCount > 1) { const p = ctx.createStereoPanner(); p.pan.value = parseFloat(document.getElementById('editorPan').value); n.connect(p); n = p; } n.connect(fg); fg.connect(ctx.destination); src.start(0); const b = await ctx.startRendering(); const meta = { title: document.getElementById('metaTitle').value }; if (format === 'wav') downloadBlob(new Blob([bufferToWav(b, {}, meta)], { type: 'audio/wav' }), 'edited.wav'); else if (format === 'mp3') downloadBlob(audioBufferToMp3(b), 'edited.mp3'); else if (format === 'ogg') downloadBlob(await audioBufferToOgg(b, meta), 'edited.ogg'); }
        function visualize() { if (!analyser || !isPlaying) { if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; drawBlankVisualizer(); return; } const c = document.getElementById('visualizer'); const cc = c.getContext('2d'); const bg = getComputedStyle(document.body).getPropertyValue('--code-bg-color'); const fg = getComputedStyle(document.body).getPropertyValue('--text-color'); analyser.fftSize = 2048; const d = new Uint8Array(analyser.frequencyBinCount); const td = new Uint8Array(analyser.fftSize); c.width = c.offsetWidth; c.height = c.offsetHeight; const type = VISUALIZER_TYPES[currentVisualizerIndex]; if (type === 'video' && videoElement.src) { c.classList.add('hidden'); videoElement.classList.remove('hidden'); return; } c.classList.remove('hidden'); videoElement.classList.add('hidden'); const draw = () => { animationFrameId = requestAnimationFrame(draw); if (!isPlaying) return; if (isAudioFileLoaded && isPlaying && audioFileBuffer) { const p = (playbackStartOffset + (audioContext.currentTime - playbackStartTime)) / audioFileBuffer.duration; if(p<=1) document.getElementById('progressBar').style.width = `${p*100}%`; } cc.fillStyle = bg; cc.fillRect(0, 0, c.width, c.height); if (type === 'line') { analyser.getByteTimeDomainData(td); cc.lineWidth = 2; cc.strokeStyle = fg; cc.beginPath(); const sw = c.width * 1.0 / td.length; let x = 0; for(let i=0; i<td.length; i++) { const v = td[i]/128.0; const y = v*c.height/2; if(i===0) cc.moveTo(x,y); else cc.lineTo(x,y); x+=sw; } cc.stroke(); } else if (type === 'circle') { analyser.getByteFrequencyData(d); const cx = c.width/2, cy = c.height/2, r = Math.min(c.width,c.height)/3.5; cc.strokeStyle = fg; cc.beginPath(); for(let i=0; i<d.length; i++) { const a = (i/d.length)*2*Math.PI; const h = (d[i]/255)*r*0.8; cc.lineTo(cx+Math.cos(a)*(r+h), cy+Math.sin(a)*(r+h)); } cc.stroke(); } else { analyser.getByteFrequencyData(d); const bw = (c.width / d.length) * 2.5; let x = 0; for (let i = 0; i < d.length; i++) { const h = (d[i] / 255) * c.height; cc.fillStyle = fg; cc.fillRect(x, c.height - h, bw, h); x += bw + 1; } } }; if (!animationFrameId) draw(); }
        function generateCode() { const s = getSettingsFromUI(); document.getElementById('codeOutput').value = `const audioContext = new AudioContext();\nconst osc = audioContext.createOscillator();\nosc.type = '${s.waveType}';\nosc.frequency.value = ${s.startFreq};\nosc.connect(audioContext.destination);\nosc.start();`; }
        function copyCode(e) { e.stopPropagation(); const c = document.getElementById('codeOutput'); c.select(); document.execCommand('copy'); }
        function editCode(e) { e.stopPropagation(); const c = document.getElementById('codeOutput'); c.readOnly = !c.readOnly; document.getElementById('editBtn').textContent = c.readOnly ? '⌨' : '⎗'; }
        function toggleTheme() { const b = document.getElementById('themeToggleBtn'); b.classList.add('animate-spin-out'); setTimeout(() => { currentThemeIndex = (currentThemeIndex + 1) % THEMES.length; document.body.className = THEMES[currentThemeIndex] === 'default' ? '' : THEMES[currentThemeIndex]; localStorage.setItem('synthTheme', THEMES[currentThemeIndex]); drawBlankVisualizer(); b.classList.remove('animate-spin-out'); b.classList.add('animate-spin-in'); setTimeout(() => b.classList.remove('animate-spin-in'), 500); }, 500); }
        function toggleButtonSide(d) { const c = document.getElementById('sideButtons'); c.classList.remove('left','right'); c.classList.add(d); localStorage.setItem('synthButtonSide', d); }
        function showResetModal(t) { document.getElementById('resetModalText').textContent = t; const m = document.getElementById('resetModalBackdrop'); m.classList.remove('hidden'); setTimeout(()=>m.classList.add('visible'), 10); }
        function hideResetModal() { const m = document.getElementById('resetModalBackdrop'); m.classList.remove('visible'); setTimeout(()=>m.classList.add('hidden'), 300); }
        function handleResetConfirm() { 
            if (currentMode === 2) {
                DAW.reset();
            } else {
                localStorage.removeItem('synthSettings'); 
                localStorage.removeItem('synthLoopMode');
                localStorage.removeItem('synthTheme');
                localStorage.removeItem('synthButtonSide');
                localStorage.removeItem('synthVisualizerType');
                if (videoObjectUrl) URL.revokeObjectURL(videoObjectUrl);
                ejectAudio();
                loadSettings(DEFAULTS);
                document.querySelectorAll('#equalizerContainer input').forEach(s => s.value = 0);
                document.getElementById('playbackRate').value = 1;
            }
            hideResetModal(); 
        }
        function resetButtonAction(e) { 
            e.stopPropagation(); 
            const now = Date.now();
            if (now - lastResetClickTime < 2000) {
                localStorage.removeItem('synthDefaultMode');
                const m = document.getElementById('startModalBackdrop'); 
                m.classList.remove('hidden'); 
                setTimeout(()=>m.classList.add('visible'), 10);
                return;
            }
            lastResetClickTime = now;
            showResetModal(currentMode === 2 ? "Clear Project?" : isAudioFileLoaded ? "Reset Adjustments?" : "Reset Synth?"); 
        }
        function loadSettings(c) { const s = c || JSON.parse(localStorage.getItem('synthSettings') || JSON.stringify(DEFAULTS)); Object.keys(DEFAULTS).forEach(k => { const e = document.getElementById(k), i = document.getElementById(k+'Input'); if(e) e.value = s[k]; if(i) i.value = s[k]; }); }
        function saveSettings() { localStorage.setItem('synthSettings', JSON.stringify(getSettingsFromUI())); }
        function loadAudioFile(f) { initContext(); stopCurrentSound(); ejectAudio(true); loadedFileInfo = { name: f.name, size: f.size, type: f.type }; if (f.type.startsWith('video/')) { videoObjectUrl = URL.createObjectURL(f); videoElement.src = videoObjectUrl; videoElement.classList.remove('hidden'); document.getElementById('visualizer').classList.add('hidden'); currentVisualizerIndex = VISUALIZER_TYPES.indexOf('video'); } const r = new FileReader(); r.onload = async (e) => { audioContext.decodeAudioData(e.target.result).then(b => { audioFileBuffer = b; originalAudioFileBuffer = b; loadedFileInfo.duration = b.duration; updateFileInfoDisplay(loadedFileInfo); toggleAudioEditorMode(true, f.type); }).catch(e => { alert("Error decoding"); ejectAudio(); }); }; r.readAsArrayBuffer(f); }
        function updateFileInfoDisplay(i) { document.getElementById('audioFileInfoContainer').innerHTML = i && i.duration ? `<b>File:</b> ${i.name}<br><b>Dur:</b> ${i.duration.toFixed(2)}s` : ''; }
        function toggleAudioEditorMode(l, t='') { isAudioFileLoaded = l; document.getElementById('synthControls').classList.toggle('hidden', l); document.getElementById('audioEditorContainer').classList.toggle('hidden', !l); document.getElementById('codeOutputContainer').classList.toggle('hidden', l); document.getElementById('metadataContainer').classList.toggle('hidden', !l); loopMode = 0; updateLoopButton(); 
            const btn1 = document.getElementById('playBtn'); const btn2 = document.getElementById('mobPlayBtn'); const txt = l ? 'PLAY' : 'SOUND'; btn1.textContent = txt; btn2.innerHTML = `<b>${txt}</b>`;
            document.getElementById('globalTitle').textContent = l ? "./EDITOR." : "./SYNTH."; if(!t.startsWith('video/')) { videoElement.classList.add('hidden'); document.getElementById('visualizer').classList.remove('hidden'); if(VISUALIZER_TYPES[currentVisualizerIndex] === 'video') currentVisualizerIndex = 0; } 
            const eBtn = document.getElementById('ejectBtn'); const mEBtn = document.getElementById('mobEjectBtn');
            if(l) { eBtn.classList.remove('hidden'); mEBtn.classList.remove('hidden'); } else { eBtn.classList.add('hidden'); mEBtn.classList.add('hidden'); }
        }
        async function playAudioFile(o=0) { if (!audioFileBuffer) return; await initContext(); audioFileSource = audioContext.createBufferSource(); audioFileSource.buffer = audioFileBuffer; audioFileSource.loop = loopMode > 0; audioFileSource.playbackRate.value = parseFloat(document.getElementById('playbackRate').value); if (videoElement.src) { videoElement.currentTime = o; videoElement.playbackRate = audioFileSource.playbackRate.value; videoElement.play(); } distortionNode = audioContext.createWaveShaper(); distortionNode.curve = makeDistortionCurve(parseFloat(document.getElementById('editorDistortion').value)); distortionNode.oversample = '4x'; bitCrusherNode = audioContext.createWaveShaper(); bitCrusherNode.curve = makeBitCrusherCurve(parseFloat(document.getElementById('editorBitrate').value)); bitCrusherNode.oversample = 'none'; wetGainNode = audioContext.createGain(); dryGainNode = audioContext.createGain(); const rv = parseFloat(document.getElementById('editorReverb').value); wetGainNode.gain.value = rv; dryGainNode.gain.value = 1-rv; let n = audioFileSource; eqBands = []; const freqs = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000]; const sld = document.querySelectorAll('#equalizerContainer input'); freqs.forEach((f, i) => { const eq = audioContext.createBiquadFilter(); eq.type = i===0?'lowshelf':i===freqs.length-1?'highshelf':'peaking'; eq.frequency.value = f; eq.gain.value = parseFloat(sld[i].value); n.connect(eq); n = eq; eqBands.push(eq); }); n.connect(distortionNode); const m = audioContext.createGain(); distortionNode.connect(bitCrusherNode); bitCrusherNode.connect(dryGainNode); bitCrusherNode.connect(wetGainNode); wetGainNode.connect(convolverNode); dryGainNode.connect(m); convolverNode.connect(m); n = m; pannerNode = audioContext.createStereoPanner(); pannerNode.pan.value = parseFloat(document.getElementById('editorPan').value); n.connect(pannerNode); n = pannerNode; n.connect(analyser); playbackStartOffset = o; playbackStartTime = audioContext.currentTime; audioFileSource.start(0, o); isPlaying = true; audioFileSource.onended = () => { if (!audioFileSource.loop && isPlaying) { stopCurrentSound(); const b1=document.getElementById('playBtn'), b2=document.getElementById('mobPlayBtn'); b1.textContent='PLAY'; b2.innerHTML='<b>PLAY</b>'; playbackStartOffset = 0; document.getElementById('progressBar').style.width = '0%'; } }; document.getElementById('reverseBtn').disabled = true; visualize(); }
        function toggleAudioPlayback() { if (isPlaying) { playbackStartOffset += audioContext.currentTime - playbackStartTime; stopCurrentSound(); const b1=document.getElementById('playBtn'), b2=document.getElementById('mobPlayBtn'); b1.textContent='PLAY'; b2.innerHTML='<b>PLAY</b>'; } else if (audioFileBuffer) { playAudioFile(playbackStartOffset % audioFileBuffer.duration); const b1=document.getElementById('playBtn'), b2=document.getElementById('mobPlayBtn'); b1.textContent='PAUSE'; b2.innerHTML='<b>PAUSE</b>'; } }
        function ejectAudio(l=false) { stopCurrentSound(); if (isRecording) toggleRecording(); audioFileBuffer = null; originalAudioFileBuffer = null; loadedFileInfo = {}; if (videoObjectUrl) URL.revokeObjectURL(videoObjectUrl); videoElement.src = ''; videoElement.classList.add('hidden'); if(!l) toggleAudioEditorMode(false); drawBlankVisualizer(); }
        function reverseAudio() { if(!originalAudioFileBuffer || isPlaying) return; isReversed = !isReversed; const b = document.getElementById('reverseBtn'); b.classList.toggle('active', isReversed); b.textContent = "Processing..."; setTimeout(() => { if (isReversed) { const n = audioContext.createBuffer(originalAudioFileBuffer.numberOfChannels, originalAudioFileBuffer.length, originalAudioFileBuffer.sampleRate); for(let i=0;i<n.numberOfChannels;i++) n.copyToChannel(new Float32Array(originalAudioFileBuffer.getChannelData(i)).reverse(), i); audioFileBuffer = n; } else audioFileBuffer = originalAudioFileBuffer; b.textContent = "Reverse"; }, 10); }
        async function toggleRecording() { 
            if (isRecording) { 
                mediaRecorder.stop(); isRecording = false; 
                const setRec = (id, txt) => { const b = document.getElementById(id); b.classList.remove('recording'); b.innerHTML = txt; };
                setRec('recBtn', '<b>REC</b>'); setRec('mobRecBtn', '<b>REC</b>');
                document.querySelectorAll('#playBtn, #ejectBtn').forEach(b => b.disabled = false); 
            } else { 
                await initContext(); 
                try {
                    const s = await navigator.mediaDevices.getUserMedia({ audio: true }); 
                    ejectAudio(true);
                    isRecording = true; 
                    recordedChunks = []; 
                    mediaRecorder = new MediaRecorder(s); 
                    mediaRecorder.ondataavailable = (e) => { if(e.data.size>0) recordedChunks.push(e.data); }; 
                    mediaRecorder.onstop = () => { 
                        s.getTracks().forEach(t => t.stop()); 
                        loadAudioFile(new File([new Blob(recordedChunks, { type: 'audio/webm' })], 'recording.webm', { type: 'audio/webm' })); 
                    }; 
                    mediaRecorder.start(); 
                    const setRec = (id, txt) => { const b = document.getElementById(id); b.classList.add('recording'); b.innerHTML = txt; };
                    setRec('recBtn', '<b>■</b>'); setRec('mobRecBtn', '<b>■</b>');
                    document.querySelectorAll('#playBtn, #ejectBtn').forEach(b => b.disabled = true); 
                } catch(e) {
                    alert("Microphone access denied or error: " + e.message);
                }
            } 
        }

        var DAW = {
            tracks: [],
            settings: { bpm: 120, duration: 30, snap: 16, useBpm: false },
            isPlaying: false,
            startTime: 0,
            playbackOffset: 0,
            lookahead: 25.0,
            scheduleAheadTime: 0.1,
            nextNoteTime: 0.0,
            timerID: null,
            history: [],
            historyIndex: -1,
            selectedTrackId: null,
            gridCanvas: null,
            gridCtx: null,
            pixelsPerSecond: 100,
            toolMode: 'pointer',
            selectionStart: null,
            playingNotes: {}, 
            activeKeys: {},
            clipboard: [],
            isRecordingMidi: false,
            recStartTime: 0,
            recNotes: {},
            drawMode: true,
            multiSelection: [],
            mobileResizeMode: false,
            mobileResizeTarget: null,
            mobileMoveMode: false,
            longPressTimer: null,
            activeTouches: new Set(),
            player: null,
            loader: null,
            mobileSelectMode: false,
            dragInitialState: [],
            zoomLevel: 1.0,
            keyboardOctaveOffset: 0,
            rowHeight: 20,

            init() {
                this.gridCanvas = document.getElementById('gridCanvas');
                this.gridCtx = this.gridCanvas.getContext('2d');
                this.setupPianoRoll();
                this.setupGridInteractions();
                this.setupMobileKeyboard();
                this.addTrack('Piano', 'Acoustic Grand Piano');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.saveState();
                this.initEqEffects();
                this.initPlayer();
                
                const ruler = document.querySelector('#gridContainer > div:first-child');
                
                document.getElementById('playhead').addEventListener('mousedown', (e) => this.handlePlayheadScrub(e));
                
                const handleTouchScrub = (e) => {
                    e.preventDefault(); e.stopPropagation();
                    const touch = e.touches[0];
                    this.handlePlayheadScrub({
                         stopPropagation: () => {},
                         preventDefault: () => {},
                         clientX: touch.clientX
                    });
                };
                
                const playhead = document.getElementById('playhead');
                playhead.addEventListener('touchstart', handleTouchScrub, {passive: false});
                
                const gridContainer = document.getElementById('gridContainer');
                gridContainer.addEventListener('scroll', (e) => {
                    const sidebar = document.getElementById('keysSidebar');
                    sidebar.scrollTop = e.target.scrollTop;
                    if (e.target.scrollLeft + e.target.clientWidth > this.gridCanvas.width - 100) {
                        this.gridCanvas.width += 1000;
                        this.drawGrid();
                    }
                });
            },

            initEqEffects() {
                const eqContainer = document.getElementById('fxEqContainer');
                eqContainer.innerHTML = '';
                const frequencies = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000];
                const tooltips = ["Exteme-Low-Bass (Rumble)", "Center of Bass", "Low-end Mid (Vocal/Instruments)", "Low-mid Focal (Electric/Vocal/Box)", "Center Mid (Rhythm/Nasal)", "High Mid (Harmonics/Orchestral)", "Low-end High (Clarity/ [S-T] Noise)", "Core High-end (Air/Echo)", "Highest Range (Overtone/Sharp)"];
                frequencies.forEach((freq, i) => {
                    const div = document.createElement('div');
                    div.className = 'eq-band';
                    const s = document.createElement('input'); s.type='range'; s.className='vertical'; s.min=-20; s.max=20; s.value=0; s.step=1; s.id=`fxEq${i}`; s.style.height='80px';
                    const l = document.createElement('span'); l.style.fontSize='0.7em'; l.textContent = freq<1000?freq:(freq/1000)+'k';
                    const t = document.createElement('span'); t.className='tooltip'; t.textContent = tooltips[i];
                    div.appendChild(l); div.appendChild(s); div.appendChild(t); eqContainer.appendChild(div);
                });
            },
            
            initPlayer() {
                if (!this.player && typeof WebAudioFontPlayer !== 'undefined') {
                    if(!audioContext) initContext();
                    this.player = new WebAudioFontPlayer();
                    this.loader = new WebAudioFontLoader(this.player);
                }
            },

            ensureInstrumentLoaded(category, name) {
                if (category === 'legacy' || category === 'Legacy') return;
                this.initPlayer();
                const instr = getInstrumentData(category, name);
                
                if (instr && window[instr.var]) return;

                if (instr) {
                    const globalTitle = document.getElementById('globalTitle');
                    const originalTitle = globalTitle.textContent;
                    globalTitle.textContent = 'Loading...';
                    
                    const timeout = setTimeout(() => {
                        if (globalTitle.textContent === 'Loading...') {
                            globalTitle.textContent = originalTitle;
                        }
                    }, 20000);

                    this.loader.startLoad(audioContext, 'js/webaudiofontdata/sound/' + instr.file, instr.var);
                    this.loader.waitLoad(() => {
                        clearTimeout(timeout);
                        console.log('Loaded ' + name);
                        if(globalTitle.textContent === 'Loading...') globalTitle.textContent = originalTitle;
                    });
                }
            },

            setupPianoRoll() {
                const sidebar = document.getElementById('keysSidebar');
                sidebar.innerHTML = '';
                const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
                for(let i = 108; i >= 24; i--) {
                    const key = document.createElement('div');
                    const noteName = notes[i % 12];
                    const octave = Math.floor(i / 12) - 1;
                    key.className = `piano-key ${noteName.includes('#') ? 'black' : 'white'}`;
                    key.textContent = `${noteName}${octave}`;
                    key.dataset.pitch = i;
                    key.style.height = this.rowHeight + 'px';
                    key.onclick = () => this.previewNote(i);
                    sidebar.appendChild(key);
                }
                const sidebarEl = document.getElementById('keysSidebar');
                const gridContainer = document.getElementById('gridContainer');
                sidebarEl.addEventListener('wheel', (e) => { gridContainer.scrollTop += e.deltaY; });
                sidebarEl.scrollTop = (108 - 60) * this.rowHeight;
            },
            
            incrementMobileOctave(delta) {
                this.keyboardOctaveOffset += (delta * 12);
                if (this.keyboardOctaveOffset > 36) this.keyboardOctaveOffset = 36;
                if (this.keyboardOctaveOffset < -24) this.keyboardOctaveOffset = -24;
                document.getElementById('mobilePitchInput').value = this.keyboardOctaveOffset / 12;
                this.setupMobileKeyboard();
            },

            setupMobileKeyboard() {
                const container = document.getElementById('mobileKeyboard');
                container.innerHTML = '';
                
                const shift = this.keyboardOctaveOffset;
                
                const createRow = (baseStartPitch, baseEndPitch) => {
                    const startPitch = baseStartPitch + shift;
                    const endPitch = baseEndPitch + shift;
                    
                    const row = document.createElement('div');
                    row.className = 'mobile-key-row';
                    const whiteKeyCount = 14; 
                    const whiteKeyWidth = 100 / whiteKeyCount; 
                    
                    const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
                    let currentWhiteIndex = 0;
                    
                    for(let i = startPitch; i <= endPitch; i++) {
                        const key = document.createElement('div');
                        const noteName = notes[i % 12];
                        const isBlack = noteName.includes('#');
                        const octave = Math.floor(i / 12) - 1;
                        
                        key.dataset.pitch = i;
                        
                        if (!isBlack) {
                            key.className = 'mobile-key white';
                            key.style.width = `${whiteKeyWidth}%`;
                            key.textContent = noteName + octave;
                            row.appendChild(key);
                            currentWhiteIndex++;
                        } else {
                            key.className = 'mobile-key black';
                            key.title = noteName + octave;
                            key.style.left = `${(currentWhiteIndex * whiteKeyWidth) - (whiteKeyWidth * 0.3)}%`; 
                            key.style.width = `${whiteKeyWidth * 0.6}%`;
                            row.appendChild(key);
                        }

                        key.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            this.startRealtimeNote(i);
                            key.classList.add('active-touch');
                            const up = () => {
                                this.stopRealtimeNote(i);
                                key.classList.remove('active-touch');
                                window.removeEventListener('mouseup', up);
                                window.removeEventListener('mouseleave', up);
                            };
                            window.addEventListener('mouseup', up);
                            window.addEventListener('mouseleave', up);
                        });
                    }
                    
                    const handleTouch = (e) => {
                        e.preventDefault();
                        const touches = e.touches;
                        const newActivePitches = new Set();

                        for(let i=0; i<touches.length; i++) {
                            const touch = touches[i];
                            const element = document.elementFromPoint(touch.clientX, touch.clientY);
                            if (element && element.classList.contains('mobile-key')) {
                                const pitch = parseInt(element.dataset.pitch);
                                newActivePitches.add(pitch);
                            }
                        }

                        this.activeTouches.forEach(pitch => {
                            if(!newActivePitches.has(pitch)) {
                                this.stopRealtimeNote(pitch);
                                const el = document.querySelector(`.mobile-key[data-pitch="${pitch}"]`);
                                if(el) el.classList.remove('active-touch');
                                this.activeTouches.delete(pitch);
                            }
                        });

                        newActivePitches.forEach(pitch => {
                            if(!this.activeTouches.has(pitch)) {
                                this.startRealtimeNote(pitch);
                                const el = document.querySelector(`.mobile-key[data-pitch="${pitch}"]`);
                                if(el) el.classList.add('active-touch');
                                this.activeTouches.add(pitch);
                            }
                        });
                    };
                    
                    const endTouch = (e) => {
                        e.preventDefault();
                        if (e.touches.length === 0) {
                            this.activeTouches.forEach(pitch => {
                                this.stopRealtimeNote(pitch);
                                const el = document.querySelector(`.mobile-key[data-pitch="${pitch}"]`);
                                if(el) el.classList.remove('active-touch');
                            });
                            this.activeTouches.clear();
                        } else {
                            handleTouch(e); 
                        }
                    };

                    row.addEventListener('touchstart', handleTouch, {passive: false});
                    row.addEventListener('touchmove', handleTouch, {passive: false});
                    row.addEventListener('touchend', endTouch);
                    row.addEventListener('touchcancel', endTouch);
                    
                    return row;
                };
                
                container.appendChild(createRow(72, 95)); 
                container.appendChild(createRow(48, 71)); 
                container.appendChild(createRow(24, 47)); 
            },
            
            toggleKeys() {
                const kb = document.getElementById('mobileKeyboard');
                const btn = document.getElementById('wsKeysBtn');
                if (kb.style.display === 'flex') {
                    kb.style.display = 'none';
                    btn.classList.remove('active');
                } else {
                    kb.style.display = 'flex';
                    btn.classList.add('active');
                }
            },

            resize() {
                const container = document.getElementById('gridContainer');
                const width = Math.max(container.offsetWidth, this.settings.duration * this.pixelsPerSecond) + 2000;
                const height = 108 * this.rowHeight; 
                this.gridCanvas.width = width;
                this.gridCanvas.height = height;
                document.getElementById('playhead').style.height = height + 'px';
                this.drawGrid();
            },

            drawGrid() {
                const w = this.gridCanvas.width, h = this.gridCanvas.height;
                const ctx = this.gridCtx;
                const style = getComputedStyle(document.body);
                ctx.fillStyle = style.getPropertyValue('--grid-bg');
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = style.getPropertyValue('--grid-line');
                for(let y=0; y<h; y+=this.rowHeight) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
                const beatWidth = (60 / this.settings.bpm) * this.pixelsPerSecond;
                const snapWidth = beatWidth / (this.settings.snap / 4);
                for(let x=0; x<w; x+=snapWidth) {
                    ctx.beginPath();
                    ctx.lineWidth = (Math.abs(x % beatWidth) < 1) ? 1 : 0.5;
                    ctx.strokeStyle = (Math.abs(x % beatWidth) < 1) ? style.getPropertyValue('--grid-beat') : style.getPropertyValue('--grid-line');
                    ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                }
            },

            addTrack(category, name, data) {
                const id = Date.now();
                const track = { id, name: name || category, type: category, instrument: name, data: data || {}, notes: [], muted: false, solo: false, vol: 1, fx: { dist: 0, rev: 0, bit: 16, eq: [0,0,0,0,0,0,0,0,0] }, transpose: 0, color: '#ffffff' };
                this.tracks.push(track);
                if (category !== 'sample' && category !== 'synth' && category !== 'legacy' && category !== 'Legacy') {
                    this.ensureInstrumentLoaded(category, name);
                }
                this.renderTrackList();
                this.selectTrack(id);
                this.saveState();
            },

            renderTrackList() {
                const el = document.getElementById('trackList');
                el.innerHTML = '';
                this.tracks.forEach(t => {
                    const div = document.createElement('div');
                    div.className = `track-header ${t.id === this.selectedTrackId ? 'selected' : ''}`;
                    div.innerHTML = `<span>${t.name}</span><div class="track-controls"><button class="track-btn" onclick="DAW.removeTrack(${t.id}, event)">X</button></div>`;
                    div.onclick = () => this.selectTrack(t.id);
                    div.oncontextmenu = (e) => { e.preventDefault(); this.showTrackContext(e, t.id); };
                    
                    let pressTimer;
                    div.addEventListener('touchstart', (e) => {
                        pressTimer = setTimeout(() => {
                            this.showTrackContext(e.touches[0], t.id);
                        }, 500);
                    }, {passive: false});
                    div.addEventListener('touchend', () => clearTimeout(pressTimer));
                    div.addEventListener('touchmove', () => clearTimeout(pressTimer));

                    el.appendChild(div);
                });
                const addBtn = document.createElement('button'); addBtn.textContent = "+ Add Track"; addBtn.style.width="100%"; 
                addBtn.onclick = (e) => { 
                    const m = document.getElementById('addTrackMenu'); 
                    m.innerHTML = '';
                    
                    const showCategories = () => {
                        m.innerHTML = '';
                        const sampleBtn = document.createElement('button'); 
                        sampleBtn.textContent = 'Sampler'; 
                        sampleBtn.style.width = '100%';
                        sampleBtn.onclick = () => { DAW.addTrack('sample', 'Sampler'); m.style.display='none'; }; 
                        m.appendChild(sampleBtn);

                        Object.keys(INSTRUMENT_LIBRARY).forEach(cat => {
                            const btn = document.createElement('button');
                            btn.style.display = 'flex';
                            btn.style.justifyContent = 'space-between';
                            btn.style.width = '100%';
                            btn.innerHTML = `<span>${cat}</span><span>▶</span>`;
                            btn.onclick = (ev) => { ev.stopPropagation(); showInstruments(cat); };
                            m.appendChild(btn);
                        });
                    };

                    const showInstruments = (cat) => {
                        m.innerHTML = '';
                        const backBtn = document.createElement('button');
                        backBtn.textContent = '◀ Back';
                        backBtn.style.background = 'rgba(128,128,128,0.3)';
                        backBtn.style.width = '100%';
                        backBtn.onclick = (ev) => { ev.stopPropagation(); showCategories(); };
                        m.appendChild(backBtn);

                        INSTRUMENT_LIBRARY[cat].forEach(inst => {
                            const btn = document.createElement('button');
                            btn.textContent = inst.name;
                            btn.style.width = '100%';
                            btn.onclick = () => { DAW.addTrack(cat, inst.name); m.style.display='none'; };
                            m.appendChild(btn);
                        });
                    };

                    showCategories();
                    m.style.display = 'flex'; 
                    m.style.left = e.clientX+'px'; 
                    m.style.top = e.clientY+'px'; 
                    document.addEventListener('click', ()=>m.style.display='none', {once:true}); 
                    e.stopPropagation(); 
                };
                el.appendChild(addBtn);
            },

            showTrackContext(e, id) { 
                const m = document.getElementById('trackContextMenu'); 
                m.style.display = 'flex'; 
                m.style.left = e.clientX+'px'; 
                m.style.top = e.clientY+'px'; 
                m.dataset.id = id; 
                document.addEventListener('click', () => m.style.display = 'none', {once:true}); 
            },
            ctxRename() { const id = parseInt(document.getElementById('trackContextMenu').dataset.id); const t = this.tracks.find(x=>x.id===id); if(t) { const n = prompt("Rename:", t.name); if(n) { t.name = n; this.renderTrackList(); this.saveState(); } } },
            ctxDelete() { const id = parseInt(document.getElementById('trackContextMenu').dataset.id); this.removeTrack(id, {stopPropagation:()=>{}}); },
            ctxChangeType(e) { 
                if(e) e.stopPropagation();
                const m = document.getElementById('typeSelectMenu'); 
                const ctxM = document.getElementById('trackContextMenu');
                m.dataset.id = ctxM.dataset.id;
                
                const showCategories = () => {
                    m.innerHTML = '';
                    Object.keys(INSTRUMENT_LIBRARY).forEach(cat => {
                        const btn = document.createElement('button');
                        btn.style.display = 'flex';
                        btn.style.justifyContent = 'space-between';
                        btn.style.width = '100%';
                        btn.innerHTML = `<span>${cat}</span><span>▶</span>`;
                        btn.onclick = (ev) => { ev.stopPropagation(); showInstruments(cat); };
                        m.appendChild(btn);
                    });
                };

                const showInstruments = (cat) => {
                    m.innerHTML = '';
                    const backBtn = document.createElement('button');
                    backBtn.textContent = '◀ Back';
                    backBtn.style.background = 'rgba(128,128,128,0.3)';
                    backBtn.style.width = '100%';
                    backBtn.onclick = (ev) => { ev.stopPropagation(); showCategories(); };
                    m.appendChild(backBtn);

                    INSTRUMENT_LIBRARY[cat].forEach(inst => {
                        const btn = document.createElement('button');
                        btn.textContent = inst.name;
                        btn.style.width = '100%';
                        btn.onclick = () => DAW.setType(cat, inst.name);
                        m.appendChild(btn);
                    });
                };

                showCategories();
                const rect = ctxM.getBoundingClientRect();
                m.style.left = rect.left + 'px'; m.style.top = rect.top + 'px'; m.style.display = 'flex';
                document.addEventListener('click', ()=>m.style.display='none', {once:true});
            },
            ctxColor(e) {
                if(e) e.stopPropagation();
                const picker = document.getElementById('trackColorPicker');
                picker.click();
            },
            setTrackColor(color) {
                const id = parseInt(document.getElementById('trackContextMenu').dataset.id);
                const t = this.tracks.find(x=>x.id===id);
                if(t) {
                    t.color = color;
                    this.renderNotes();
                    this.saveState();
                }
            },
            setType(category, name) { const id = parseInt(document.getElementById('typeSelectMenu').dataset.id); const t = this.tracks.find(x=>x.id===id); if(t) { t.type = category; t.instrument = name; t.name = name; this.ensureInstrumentLoaded(category, name); this.saveState(); this.renderTrackList(); } },

            removeTrack(id, e) { e.stopPropagation(); this.tracks = this.tracks.filter(t => t.id !== id); if(this.selectedTrackId === id) this.selectedTrackId = this.tracks[0] ? this.tracks[0].id : null; this.renderTrackList(); this.renderNotes(); this.saveState(); },
            selectTrack(id) { 
                this.selectedTrackId = id; 
                const t = this.tracks.find(x=>x.id===id); 
                if(t) { 
                    document.getElementById('wsTrackVol').value = t.vol; 
                    document.getElementById('wsTrackVolInput').value = t.vol; 
                    document.getElementById('wsTranspose').value = t.transpose;
                    document.getElementById('wsTransposeInput').value = t.transpose;
                } 
                this.renderTrackList(); 
                this.renderNotes(); 
            },

            renderNotes() {
                document.querySelectorAll('.note-block').forEach(n => n.remove());
                document.getElementById('resizeControls').style.display = 'none';
                document.getElementById('dragHandle').style.display = 'none';
                
                const track = this.tracks.find(t => t.id === this.selectedTrackId);
                if(!track) return;
                const container = document.getElementById('gridContainer');
                
                let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
                let selectedCount = 0;

                track.notes.forEach(n => {
                    const div = document.createElement('div');
                    div.className = `note-block ${n.selected ? 'selected' : ''}`;
                    if(this.mobileResizeMode && this.mobileResizeTarget === n) div.classList.add('resizing-mobile');
                    if(this.mobileMoveMode) div.classList.add('moving-mobile');
                    
                    const left = (n.start * this.pixelsPerSecond);
                    const width = (n.duration * this.pixelsPerSecond);
                    const top = ((108 - n.pitch) * this.rowHeight);
                    
                    div.style.left = left + 'px';
                    div.style.width = width + 'px';
                    div.style.top = top + 'px';
                    div.style.height = (this.rowHeight - 2) + 'px';
                    
                    if (track.color && track.color !== '#ffffff' && !n.selected) {
                        div.style.backgroundColor = track.color;
                    }
                    
                    if (n.selected) {
                        selectedCount++;
                        minX = Math.min(minX, left);
                        maxX = Math.max(maxX, left + width);
                        maxY = Math.max(maxY, top + this.rowHeight);
                    }

                    div.dataset.pitch = n.pitch; div.dataset.start = n.start;
                    div.id = `note-${n.pitch}-${n.start}`; 
                    
                    const resize = document.createElement('div'); resize.className = 'note-resize-handle'; div.appendChild(resize);
                    
                    div.onmousedown = (e) => this.handleNoteMouseDown(e, n, div);
                    div.addEventListener('touchstart', (e) => this.handleNoteTouchStart(e, n, div), {passive: false});
                    div.addEventListener('touchmove', (e) => this.handleNoteTouchMove(e, n, div), {passive: false});
                    div.addEventListener('touchend', (e) => this.handleNoteTouchEnd(e, n, div));
                    div.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); this.showGridContext(e); };
                    container.appendChild(div);
                });

                if (this.mobileResizeMode && this.mobileResizeTarget) {
                    const rCtrl = document.getElementById('resizeControls');
                    const n = this.mobileResizeTarget;
                    rCtrl.style.display = 'flex';
                    rCtrl.style.left = (n.start * this.pixelsPerSecond) + 'px';
                    rCtrl.style.top = (((108 - n.pitch) * this.rowHeight) + this.rowHeight + 2) + 'px';
                }
                
                if (selectedCount > 0 && !this.mobileMoveMode && !this.mobileResizeMode) {
                    const dh = document.getElementById('dragHandle');
                    dh.style.display = 'flex';
                    dh.style.left = (maxX + 5) + 'px';
                    dh.style.top = (maxY + 5) + 'px';
                    
                    let startX, startY;
                    const handleDragStart = (cx, cy) => {
                        startX = cx; startY = cy;
                        this.startDragSelection();
                    };
                    dh.onmousedown = (e) => { e.stopPropagation(); e.preventDefault(); handleDragStart(e.clientX, e.clientY); };
                    dh.ontouchstart = (e) => { e.stopPropagation(); e.preventDefault(); handleDragStart(e.touches[0].clientX, e.touches[0].clientY); };
                    
                    const handleDragMove = (cx, cy) => {
                        const dx = cx - startX; const dy = cy - startY;
                        this.moveVisuals(dx, dy);
                    };
                    const mouseMove = (e) => { if(startX) { e.preventDefault(); handleDragMove(e.clientX, e.clientY); }};
                    const touchMove = (e) => { if(startX) { e.preventDefault(); handleDragMove(e.touches[0].clientX, e.touches[0].clientY); }};
                    
                    window.addEventListener('mousemove', mouseMove);
                    window.addEventListener('touchmove', touchMove, {passive: false});
                    
                    const handleDragEnd = () => { 
                        if(startX) { 
                            this.commitDragSelection();
                            startX=null; 
                            window.removeEventListener('mousemove', mouseMove);
                            window.removeEventListener('touchmove', touchMove);
                        } 
                    };
                    window.addEventListener('mouseup', handleDragEnd); 
                    window.addEventListener('touchend', handleDragEnd);
                }
            },
            
            startDragSelection() {
               const track = this.tracks.find(t => t.id === this.selectedTrackId);
               this.dragInitialState = track.notes.filter(n=>n.selected).map(n=>({
                   note: n, originalStart: n.start, originalPitch: n.pitch
               }));
               this.currentDragDelta = {x: 0, y: 0};
            },
            
            moveVisuals(dx, dy) {
                const ppS = this.pixelsPerSecond;
                this.currentDragDelta = {x: dx, y: dy};
                
                this.dragInitialState.forEach(state => {
                    const div = document.getElementById(`note-${state.originalPitch}-${state.originalStart}`);
                    if(div) {
                        const left = (state.originalStart * ppS) + dx;
                        const top = ((108 - state.originalPitch) * this.rowHeight) + dy;
                        div.style.left = left + 'px';
                        div.style.top = top + 'px';
                    }
                });
                
                const dh = document.getElementById('dragHandle');
                const initialMaxX = Math.max(...this.dragInitialState.map(s => (s.originalStart + s.note.duration)*ppS));
                const initialMaxY = Math.max(...this.dragInitialState.map(s => ((108-s.originalPitch)*this.rowHeight) + this.rowHeight));
                dh.style.left = (initialMaxX + dx + 5) + 'px';
                dh.style.top = (initialMaxY + dy + 5) + 'px';
            },
            
            commitDragSelection() {
                const dx = this.currentDragDelta.x;
                const dy = this.currentDragDelta.y;
                const ppS = this.pixelsPerSecond;
                const snapTime = (60/this.settings.bpm) / (this.settings.snap/4);
                
                this.dragInitialState.forEach(state => {
                    let ns = state.originalStart + (dx / ppS);
                    state.note.start = Math.max(0, Math.round(ns / snapTime) * snapTime);
                    const pDiff = -Math.round(dy / this.rowHeight);
                    const newP = state.originalPitch + pDiff;
                    if(newP >= 24 && newP <= 108) state.note.pitch = newP;
                });
                this.renderNotes();
                this.saveState();
            },

            toggleLasso() { this.toolMode = this.toolMode === 'lasso' ? 'pointer' : 'lasso'; document.getElementById('wsLassoBtn').classList.toggle('active', this.toolMode === 'lasso'); },
            
            toggleDrawMode() { 
                this.drawMode = !this.drawMode; 
                document.getElementById('wsDrawBtn').classList.toggle('active', !this.drawMode); 
                document.getElementById('wsDrawBtn').textContent = this.drawMode ? "♫" : "✥"; 
            },
            
            toggleRec() {
                this.isRecordingMidi = !this.isRecordingMidi;
                const btn = document.getElementById('wsRecBtn');
                const mobileBtn = document.getElementById('mobileRecBtn');
                btn.classList.toggle('recording', this.isRecordingMidi);
                mobileBtn.classList.toggle('recording', this.isRecordingMidi);
                if(this.isRecordingMidi) {
                    if(!this.isPlaying) this.play();
                    this.recStartTime = audioContext.currentTime;
                    this.recNotes = {};
                } else {
                    this.stop();
                    this.saveState();
                }
            },
            
            incrementTranspose(val) {
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                if(t) {
                    t.transpose = parseInt(t.transpose) + val;
                    this.updateTranspose(t.transpose);
                }
            },

            updateTranspose(val) { 
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                if(t) {
                    t.transpose = parseInt(val);
                    document.getElementById('wsTranspose').value = t.transpose; 
                    document.getElementById('wsTransposeInput').value = t.transpose; 
                    this.saveState();
                }
            },
            updateTrackVol(el) { const t = this.tracks.find(x=>x.id===this.selectedTrackId); if(t) { t.vol = parseFloat(el.value); document.getElementById('wsTrackVol').value=t.vol; document.getElementById('wsTrackVolInput').value=t.vol; this.saveState(); } },
            
            toggleBpmMode() {
                this.settings.useBpm = document.getElementById('fxUseBpm').checked;
                const group = document.getElementById('fxBpmGroup');
                if(this.settings.useBpm) {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
                this.saveState();
            },

            showEffects() {
                const t = this.tracks.find(x=>x.id===this.selectedTrackId); if(!t) return;
                document.getElementById('fxDistortion').value = t.fx.dist; document.getElementById('fxDistortionInput').value = t.fx.dist;
                document.getElementById('fxReverb').value = t.fx.rev; document.getElementById('fxReverbInput').value = t.fx.rev;
                document.getElementById('fxBitrate').value = t.fx.bit || 16; document.getElementById('fxBitrateInput').value = t.fx.bit || 16;
                for(let i=0;i<9;i++) {
                     const sl = document.getElementById(`fxEq${i}`);
                     if(sl) sl.value = t.fx.eq[i] || 0;
                }
                const m = document.getElementById('effectsModalBackdrop'); m.classList.remove('hidden'); setTimeout(()=>m.classList.add('visible'), 10);
            },
            saveEffects() {
                const saveToTrack = (t) => {
                    t.fx.dist = parseFloat(document.getElementById('fxDistortion').value);
                    t.fx.rev = parseFloat(document.getElementById('fxReverb').value);
                    t.fx.bit = parseFloat(document.getElementById('fxBitrate').value);
                    for(let i=0;i<9;i++) {
                        const sl = document.getElementById(`fxEq${i}`);
                        if(sl) t.fx.eq[i] = parseFloat(sl.value);
                    }
                };
                if(document.getElementById('fxApplyAll').checked) this.tracks.forEach(saveToTrack);
                else { const t = this.tracks.find(x=>x.id===this.selectedTrackId); if(t) saveToTrack(t); }
                this.saveState();
                const m = document.getElementById('effectsModalBackdrop'); m.classList.remove('visible'); setTimeout(()=>m.classList.add('hidden'), 300);
            },

            getFxChain(ctx, track) {
                const input = ctx.createGain();
                let output = input;

                if (track.fx.dist > 0) {
                    const dist = ctx.createWaveShaper();
                    dist.curve = makeDistortionCurve(track.fx.dist);
                    dist.oversample = '4x';
                    output.connect(dist);
                    output = dist;
                }
                
                if (track.fx.bit && track.fx.bit < 16) {
                    const bit = ctx.createWaveShaper();
                    bit.curve = makeBitCrusherCurve(track.fx.bit);
                    bit.oversample = 'none';
                    output.connect(bit);
                    output = bit;
                }

                const freqs = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000];
                if (track.fx.eq && track.fx.eq.some(v => v !== 0)) {
                    track.fx.eq.forEach((val, i) => {
                        if (val !== 0) {
                            const eq = ctx.createBiquadFilter();
                            eq.type = i === 0 ? 'lowshelf' : (i === 8 ? 'highshelf' : 'peaking');
                            eq.frequency.value = freqs[i];
                            eq.gain.value = val;
                            output.connect(eq);
                            output = eq;
                        }
                    });
                }

                if (track.fx.rev > 0 && convolverNode) {
                    const revGain = ctx.createGain();
                    revGain.gain.value = track.fx.rev;
                    output.connect(revGain);
                    
                    const dryGain = ctx.createGain();
                    dryGain.gain.value = 1 - track.fx.rev;
                    output.connect(dryGain);
                    
                    revGain.connect(convolverNode);
                    
                    const merge = ctx.createGain();
                    dryGain.connect(merge);
                    
                    return { input: input, output: merge };
                }

                return { input: input, output: output };
            },

            setupGridInteractions() {
                const grid = document.getElementById('gridContainer');
                this.gridCanvas.addEventListener('contextmenu', e => { e.preventDefault(); e.stopPropagation(); });
                
                const playhead = document.getElementById('playhead');
                playhead.addEventListener('mousedown', (e) => this.handlePlayheadScrub(e));
                
                const handleTouchScrub = (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePlayheadScrub({
                         stopPropagation: () => {},
                         preventDefault: () => {},
                         clientX: touch.clientX
                    });
                };
                
                const ruler = document.querySelector('#gridContainer > div:first-child');
                playhead.addEventListener('touchstart', handleTouchScrub, {passive: false});
                playhead.addEventListener('touchmove', handleTouchScrub, {passive: false});
                
                const deselectAll = (e) => {
                   if (this.tracks.length && this.selectedTrackId && !this.mobileSelectMode) {
                       const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                       if(t) {
                            t.notes.forEach(n => n.selected = false);
                            this.renderNotes();
                       }
                   }
                };

                document.body.addEventListener('mousedown', (e) => {
                    if(currentMode !== 2) return;
                    const target = e.target;
                    if(target.closest('.note-block') || target.closest('#gridContextMenu') || target.closest('.note-resize-handle') || 
                       target.closest('#dpadContainer') || target.closest('#resizeControls') || target.closest('#dragHandle') ||
                       target.closest('#canvasOptionsBtn') || target.closest('.grid-corner-trigger')) return;
                    
                    if (this.mobileMoveMode) { 
                        document.getElementById('dpadContainer').style.display = 'none';
                        this.mobileMoveMode = false;
                    }
                    
                    if (target.closest('#ws-top-bar') || target.closest('#trackList') || target.closest('#keysContainer') || target.closest('#mobile-fixed-buttons')) {
                        if (!target.tagName.match(/INPUT|BUTTON|SELECT|LABEL/i) && !target.classList.contains('track-btn')) {
                             deselectAll();
                        }
                    }
                });

                let isTouch = false;
                let touchTimer = null;
                let longPressed = false;
                let startTouchX = 0;
                let startTouchY = 0;
                let isScrolling = false;

                const handleGridInteract = (e) => {
                    if(e.type === 'mousedown' && e.button !== 0) return; 
                    
                    const rect = grid.getBoundingClientRect();
                    let clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                    let clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                    const x = clientX - rect.left + grid.scrollLeft;
                    const y = clientY - rect.top + grid.scrollTop;

                    if(e.target.classList.contains('note-block') || e.target.classList.contains('note-resize-handle') || 
                       e.target.closest('#dpadContainer') || e.target.closest('#resizeControls') || e.target.closest('#dragHandle') ||
                       e.target.closest('#canvasOptionsBtn') || e.target.closest('.grid-corner-trigger')) return;
                    
                    if (e.type === 'touchstart') {
                        isScrolling = false;
                        startTouchX = clientX;
                        startTouchY = clientY;
                        return;
                    }
                    
                    if (e.type === 'touchmove') {
                        const dx = clientX - startTouchX;
                        const dy = clientY - startTouchY;
                        if (Math.hypot(dx, dy) > 10) isScrolling = true;
                        return;
                    }
                    
                    if (e.type === 'touchend') {
                        if(isScrolling) return; 
                    }

                    if (this.mobileMoveMode) {
                        this.mobileMoveMode = false;
                        document.getElementById('dpadContainer').style.display = 'none';
                        this.renderNotes();
                        return;
                    }

                    if(this.mobileResizeMode) {
                        this.mobileResizeMode = false;
                        this.mobileResizeTarget = null;
                        this.renderNotes();
                        return;
                    }

                    if(this.toolMode === 'lasso') {
                        if(e.type === 'touchstart') e.preventDefault(); 
                        this.selectionStart = { x, y };
                        const selRect = document.getElementById('selectionRect');
                        selRect.style.display = 'block'; selRect.style.left = x+'px'; selRect.style.top = y+'px'; selRect.style.width='0px'; selRect.style.height='0px';
                        
                        const move = (ev) => {
                            const cX = ev.clientX || ev.touches[0].clientX;
                            const cY = ev.clientY || ev.touches[0].clientY;
                            const curX = cX - rect.left + grid.scrollLeft; 
                            const curY = cY - rect.top + grid.scrollTop;
                            const left = Math.min(this.selectionStart.x, curX), top = Math.min(this.selectionStart.y, curY);
                            const w = Math.abs(curX - this.selectionStart.x), h = Math.abs(curY - this.selectionStart.y);
                            selRect.style.left = left+'px'; selRect.style.top = top+'px'; selRect.style.width = w+'px'; selRect.style.height = h+'px';
                            this.selectNotesInRect(left, top, w, h);
                        };
                        const up = () => { 
                            window.removeEventListener(e.type==='mousedown'?'mousemove':'touchmove', move); 
                            window.removeEventListener(e.type==='mousedown'?'mouseup':'touchend', up); 
                            selRect.style.display = 'none'; 
                        };
                        window.addEventListener(e.type==='mousedown'?'mousemove':'touchmove', move, {passive:false}); 
                        window.addEventListener(e.type==='mousedown'?'mouseup':'touchend', up);
                        return;
                    }

                    const t = this.tracks.find(t=>t.id===this.selectedTrackId);
                    if(t && t.notes.some(n=>n.selected) && !e.shiftKey) {
                        deselectAll();
                        return;
                    }

                    if (!this.drawMode || (e.shiftKey && !this.mobileSelectMode)) {
                         const time = x / this.pixelsPerSecond;
                         this.playbackOffset = time;
                         if(audioContext) this.startTime = audioContext.currentTime - time;
                         document.getElementById('playhead').style.transform = `translateX(${x}px)`;
                         this.handlePlayheadScrub({ stopPropagation:()=>{}, preventDefault:()=>{}, clientX: clientX });
                         return;
                    }

                    const time = x / this.pixelsPerSecond;
                    const pitch = 108 - Math.floor(y / this.rowHeight);
                    const beat = 60 / this.settings.bpm;
                    const snap = beat / (this.settings.snap / 4);
                    const start = Math.floor(time / snap) * snap;
                    if(pitch >= 24 && pitch <= 108) { this.addNote(pitch, start, snap); this.previewNote(pitch); }
                };

                grid.addEventListener('mousedown', handleGridInteract);
                grid.addEventListener('touchstart', handleGridInteract, {passive: false});
                grid.addEventListener('touchmove', handleGridInteract, {passive: false});
                grid.addEventListener('touchend', handleGridInteract);
                
                grid.addEventListener('contextmenu', e => { e.preventDefault(); this.showGridContext(e); });
            },
            
            handlePlayheadScrub(e) {
                e.stopPropagation(); e.preventDefault();
                const grid = document.getElementById('gridContainer');
                const rect = grid.getBoundingClientRect();
                
                const move = (ev) => {
                    let clientX = ev.clientX;
                    if(ev.touches && ev.touches.length > 0) clientX = ev.touches[0].clientX;
                    
                    const x = clientX - rect.left + grid.scrollLeft;
                    const time = Math.max(0, x / this.pixelsPerSecond);
                    
                    this.playbackOffset = time;
                    if(audioContext) this.startTime = audioContext.currentTime - time;
                    document.getElementById('playhead').style.transform = `translateX(${time * this.pixelsPerSecond}px)`;
                };
                
                const up = () => { 
                    window.removeEventListener('mousemove', move); 
                    window.removeEventListener('mouseup', up); 
                    window.removeEventListener('touchmove', move);
                    window.removeEventListener('touchend', up);
                };
                
                window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
                window.addEventListener('touchmove', move, {passive: false}); window.addEventListener('touchend', up);
            },
            
            showGridContext(e) {
                const m = document.getElementById('gridContextMenu');
                m.style.display = 'flex'; 
                
                let x = e.clientX;
                let y = e.clientY;
                
                if(!x) { 
                    const rect = document.getElementById('canvasOptionsBtn').getBoundingClientRect();
                    x = rect.left; y = rect.top + rect.height;
                }
                
                m.style.left = 'auto'; m.style.top = 'auto'; m.style.right = 'auto'; m.style.bottom = 'auto';
                
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                if (x > w * 0.6) {
                    m.style.right = (w - x) + 'px';
                } else {
                    m.style.left = x + 'px';
                }
                
                if (y > h * 0.6) {
                    m.style.bottom = (h - y) + 'px';
                } else {
                    m.style.top = y + 'px';
                }
                
                const highlightStyle = 'style="color:var(--loop-color); font-weight:bold;"';
                
                const t = this.tracks.find(x => x.id === this.selectedTrackId);
                const hasSelection = t && t.notes.some(n => n.selected);
                
                let menuContent = '';
                if(hasSelection) {
                    menuContent += `
                    <button onclick="DAW.gridCut()">Cut</button>
                    <button onclick="DAW.gridCopy()">Copy</button>
                    <button onclick="DAW.gridDelete()">Delete</button>
                    `;
                }

                menuContent += `
                    <button onclick="DAW.gridPaste()">Paste</button>
                    <button onclick="DAW.selectAllNotes()">Select All</button> 
                    <button onclick="DAW.toggleMobileSelect()" ${this.mobileSelectMode ? highlightStyle : ''}>Select Mode</button>
                    <button onclick="DAW.toggleMobileResize()" ${this.mobileResizeMode ? highlightStyle : ''}>Resize Mode</button>
                    <button onclick="DAW.toggleMobileMove()" ${this.mobileMoveMode ? highlightStyle : ''}>Move Mode</button>
                    <button onclick="DAW.toggleDrawMode()" ${this.drawMode ? highlightStyle : ''}>Touch Mode: ${this.drawMode ? 'ON' : 'OFF'}</button>
                `;
                
                m.innerHTML = menuContent;
                document.addEventListener('click', ()=>m.style.display='none', {once:true});
            },
            
            moveOptionsBtn(pos) {
                const btn = document.getElementById('canvasOptionsBtn');
                btn.style.top = 'auto'; btn.style.bottom = 'auto'; btn.style.left = 'auto'; btn.style.right = 'auto';
                if(pos === 'tr') { btn.style.top = '10px'; btn.style.right = '10px'; }
                if(pos === 'br') { btn.style.bottom = '10px'; btn.style.right = '10px'; }
                if(pos === 'bl') { btn.style.bottom = '10px'; btn.style.left = '60px'; }
            },
            
            zoom(amount) {
                this.zoomLevel += amount;
                this.zoomLevel = Math.max(0.1, Math.min(this.zoomLevel, 5.0));
                
                this.pixelsPerSecond = 100 * this.zoomLevel;
                this.rowHeight = 20 * this.zoomLevel;
                
                this.setupPianoRoll();
                this.resize();
                this.renderNotes();
            },

            selectAllNotes() {
                const t = this.tracks.find(x => x.id === this.selectedTrackId);
                if(t) {
                    t.notes.forEach(n => n.selected = true);
                    this.renderNotes();
                    this.saveState();
                }
            },
            
            duplicateSelection() {
                const t = this.tracks.find(x => x.id === this.selectedTrackId);
                if(t) {
                    const selected = t.notes.filter(n => n.selected);
                    if(selected.length > 0) {
                        const maxEnd = Math.max(...selected.map(n => n.start + n.duration));
                        const minStart = Math.min(...selected.map(n => n.start));
                        const offset = maxEnd - minStart;
                        
                        selected.forEach(n => {
                            n.selected = false;
                        });

                        selected.forEach(n => {
                            t.notes.push({
                                pitch: n.pitch,
                                start: n.start + offset,
                                duration: n.duration,
                                selected: true
                            });
                        });
                        this.renderNotes();
                        this.saveState();
                    }
                }
            },

            gridCut() { this.gridCopy(); this.gridDelete(); },
            gridCopy() { 
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                if(t) {
                    const selected = t.notes.filter(n=>n.selected);
                    if(selected.length > 0) {
                        const minStart = Math.min(...selected.map(n=>n.start));
                        this.clipboard = {
                            notes: JSON.parse(JSON.stringify(selected)),
                            originalStart: minStart
                        };
                    }
                }
            },
            gridPaste() {
                if(!this.clipboard || !this.clipboard.notes) return;
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                if(t) {
                    const playheadTime = this.playbackOffset;
                    let offset = 0;
                    
                    if (playheadTime > 0.1) {
                        offset = playheadTime - this.clipboard.originalStart;
                    }

                    this.clipboard.notes.forEach(n => {
                        t.notes.push({ pitch: n.pitch, start: n.start + offset, duration: n.duration, selected: true });
                    });
                    this.renderNotes(); this.saveState();
                }
            },
            gridDelete() {
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                if(t) { t.notes = t.notes.filter(n=>!n.selected); this.renderNotes(); this.saveState(); }
            },
            
            toggleMobileResize() {
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                const selected = t ? t.notes.find(n=>n.selected) : null;
                if(selected) {
                    this.mobileResizeMode = true;
                    this.mobileResizeTarget = selected;
                    this.renderNotes();
                }
            },
            
            resizeSelection(delta) {
                if(this.mobileResizeMode && this.mobileResizeTarget) {
                    const snapTime = (60/this.settings.bpm) / (this.settings.snap/4);
                    let newDur = this.mobileResizeTarget.duration + (delta * snapTime);
                    this.mobileResizeTarget.duration = Math.max(snapTime, newDur);
                    this.renderNotes();
                    this.saveState();
                }
            },

            toggleMobileMove() {
                this.mobileMoveMode = !this.mobileMoveMode;
                document.getElementById('dpadContainer').style.display = this.mobileMoveMode ? 'flex' : 'none';
                this.renderNotes();
            },
            
            dpadMove(dx, dy) {
                const t = this.tracks.find(x=>x.id===this.selectedTrackId);
                if(t) {
                    const snapTime = (60/this.settings.bpm) / (this.settings.snap/4);
                    t.notes.forEach(n => {
                        if(n.selected) {
                            n.start = Math.max(0, n.start + (dx * snapTime));
                            const newP = n.pitch + dy;
                            if(newP >= 24 && newP <= 108) n.pitch = newP;
                        }
                    });
                    this.renderNotes();
                    this.saveState();
                }
            },
            
            toggleMobileSelect() {
                this.mobileSelectMode = !this.mobileSelectMode;
            },

            selectNotesInRect(x, y, w, h) {
                const track = this.tracks.find(t => t.id === this.selectedTrackId); if(!track) return;
                const ppS = this.pixelsPerSecond; const rectRight = x + w, rectBottom = y + h;
                track.notes.forEach(n => {
                    const nX = n.start * ppS; const nW = n.duration * ppS; 
                    const nY = (108 - n.pitch) * this.rowHeight; const nH = this.rowHeight;
                    if (nX < rectRight && nX + nW > x && nY < rectBottom && nY + nH > y) n.selected = true; else n.selected = false;
                });
                this.renderNotes();
            },

            addNote(pitch, start, duration) {
                const track = this.tracks.find(t => t.id === this.selectedTrackId); if(!track) return;
                track.notes.push({ pitch, start, duration, selected: false }); this.renderNotes(); this.saveState();
            },

            handleNoteMouseDown(e, note, div) {
                e.stopPropagation();
                
                if (e.button === 2 && note.selected) return;

                if(this.mobileResizeMode) return;
                
                let isResize = e.target.classList.contains('note-resize-handle');
                if(this.mobileMoveMode) isResize = false;

                const startX = e.clientX; const startY = e.clientY;
                const ppS = this.pixelsPerSecond; const snapTime = (60/this.settings.bpm) / (this.settings.snap/4);
                
                let deselectOnMouseUp = false;

                if(e.shiftKey) {
                    note.selected = !note.selected;
                } else if(!e.ctrlKey && !note.selected && this.toolMode !== 'lasso' && !this.mobileSelectMode) { 
                    this.tracks.find(t=>t.id===this.selectedTrackId).notes.forEach(n => n.selected = false); 
                    note.selected = true; 
                } else if(e.ctrlKey || this.mobileSelectMode) {
                    note.selected = !note.selected;
                } else if (!e.ctrlKey && note.selected && !isResize && !this.mobileMoveMode) {
                    deselectOnMouseUp = true;
                }

                this.renderNotes();

                const selectedNotes = this.tracks.find(t=>t.id===this.selectedTrackId).notes.filter(n=>n.selected);
                const initialStates = selectedNotes.map(n => ({ note: n, start: n.start, duration: n.duration, pitch: n.pitch }));
                let hasMoved = false;

                const move = (ev) => {
                    const dx = ev.clientX - startX; const dy = ev.clientY - startY;
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) hasMoved = true;

                    initialStates.forEach(state => {
                        if(isResize) {
                            if (state.note === note) { 
                                let nd = state.duration + (dx / ppS); state.note.duration = Math.max(snapTime, Math.round(nd / snapTime) * snapTime);
                            }
                        } else {
                            let ns = state.start + (dx / ppS); state.note.start = Math.max(0, Math.round(ns / snapTime) * snapTime);
                            const pDiff = -Math.round(dy / this.rowHeight);
                            const newP = state.pitch + pDiff;
                            if(newP >= 24 && newP <= 108) {
                                state.note.pitch = newP;
                                if(state.note === note && newP !== state.pitch) this.previewNote(newP);
                            }
                        }
                    });
                    this.renderNotes();
                };
                const up = () => { 
                    window.removeEventListener('mousemove', move); 
                    window.removeEventListener('mouseup', up); 
                    if (deselectOnMouseUp && !hasMoved && !this.mobileSelectMode) {
                        note.selected = false;
                        this.renderNotes();
                    }
                    this.saveState(); 
                };
                window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
            },
            
            handleNoteTouchStart(e, note, div) {
                if(this.mobileResizeMode) return; 
                
                if(this.mobileMoveMode) {
                    e.preventDefault();
                    if(!note.selected) {
                        this.tracks.find(t=>t.id===this.selectedTrackId).notes.forEach(n => n.selected = false); 
                        note.selected = true;
                        this.renderNotes();
                    }
                    
                    const startX = e.touches[0].clientX;
                    const startY = e.touches[0].clientY;
                    const ppS = this.pixelsPerSecond;
                    const snapTime = (60/this.settings.bpm) / (this.settings.snap/4);
                    
                    const selectedNotes = this.tracks.find(t=>t.id===this.selectedTrackId).notes.filter(n=>n.selected);
                    const initialStates = selectedNotes.map(n => ({ note: n, start: n.start, pitch: n.pitch }));
                    
                    const move = (ev) => {
                        ev.preventDefault();
                        const dx = ev.touches[0].clientX - startX;
                        const dy = ev.touches[0].clientY - startY;
                        
                        initialStates.forEach(state => {
                            let ns = state.start + (dx / ppS); state.note.start = Math.max(0, Math.round(ns / snapTime) * snapTime);
                            const pDiff = -Math.round(dy / this.rowHeight);
                            const newP = state.pitch + pDiff;
                            if(newP >= 24 && newP <= 108) state.note.pitch = newP;
                        });
                        this.renderNotes();
                    };
                    const end = () => {
                        window.removeEventListener('touchmove', move);
                        window.removeEventListener('touchend', end);
                        this.saveState();
                    };
                    window.addEventListener('touchmove', move, {passive: false});
                    window.addEventListener('touchend', end);
                    
                } else if(this.mobileSelectMode) {
                    note.selected = !note.selected;
                    this.renderNotes();
                } 
            },
            
            handleNoteTouchMove(e, note, div) {
                if(this.mobileResizeMode && this.mobileResizeTarget === note) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const ppS = this.pixelsPerSecond;
                    const snapTime = (60/this.settings.bpm) / (this.settings.snap/4);
                    const rect = div.getBoundingClientRect();
                    const width = touch.clientX - rect.left;
                    let nd = width / ppS;
                    note.duration = Math.max(snapTime, Math.round(nd / snapTime) * snapTime);
                    this.renderNotes();
                }
            },
            
            handleNoteTouchEnd(e, note, div) {
            },
            
            previewNote(pitch) { this.startRealtimeNote(pitch); setTimeout(() => this.stopRealtimeNote(pitch), 300); },
            
            startRealtimeNote(pitch) {
                if (!audioContext) initContext(); if (this.playingNotes[pitch]) return;
                const track = this.tracks.find(t => t.id === this.selectedTrackId); if(!track) return;
                this.initPlayer();

                const transposePitch = pitch + track.transpose;
                const ctx = audioContext;
                const fx = this.getFxChain(ctx, track);
                
                if (track.type === 'sample' && track.data.buffer) {
                    const source = ctx.createBufferSource();
                    source.buffer = track.data.buffer;
                    const freq = 440 * Math.pow(2, (transposePitch - 69) / 12);
                    source.playbackRate.value = freq / 440;
                    const gain = ctx.createGain();
                    gain.gain.value = track.vol;
                    source.connect(gain);
                    gain.connect(fx.input);
                    fx.output.connect(masterGainNode);
                    source.start(0);
                    this.playingNotes[pitch] = { source, gain };
                } else {
                    const instr = getInstrumentData(track.type, track.instrument);
                    if (instr && instr.cat === 'legacy') {
                        const freq = 440 * Math.pow(2, (transposePitch - 69) / 12);
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        
                        gain.gain.value = track.vol;
                        osc.frequency.setValueAtTime(freq, ctx.currentTime);
                        
                        let n = osc;
                        
                        if(instr.legacyId === 'bell') {
                            osc.type = 'sine';
                            const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 800;
                            n.connect(hp); n = hp;
                        } else if(instr.legacyId === 'pad') {
                            osc.type = 'triangle';
                            const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1000;
                            n.connect(lp); n = lp;
                        } else if(instr.legacyId === '8bit') {
                            osc.type = 'square';
                        } else {
                            osc.type = 'triangle';
                        }

                        n.connect(gain);
                        gain.connect(fx.input);
                        fx.output.connect(masterGainNode);
                        osc.start(0);
                        this.playingNotes[pitch] = { source: osc, gain: gain, legacy: true };

                    } else if (instr && window[instr.var]) {
                        const preset = window[instr.var];
                        const envelope = this.player.queueWaveTable(audioContext, fx.input, preset, audioContext.currentTime, transposePitch, 999, track.vol);
                        fx.output.connect(masterGainNode);
                        this.playingNotes[pitch] = envelope;
                    } else {
                        if(instr && !window[instr.var]) this.ensureInstrumentLoaded(track.type, track.instrument);
                    }
                }

                const key = document.querySelector(`.piano-key[data-pitch="${pitch}"]`); if(key) key.classList.add('active');
                const mobileKey = document.querySelector(`.mobile-key[data-pitch="${pitch}"]`); if(mobileKey) mobileKey.classList.add('active-touch');

                if(this.isRecordingMidi) {
                     const playTime = (audioContext.currentTime - this.startTime) % this.settings.duration;
                     this.recNotes[pitch] = { start: playTime };
                }
            },

            stopRealtimeNote(pitch) {
                const key = document.querySelector(`.piano-key[data-pitch="${pitch}"]`); 
                if(key) key.classList.remove('active');
                const mobileKey = document.querySelector(`.mobile-key[data-pitch="${pitch}"]`); if(mobileKey) mobileKey.classList.remove('active-touch');

                const note = this.playingNotes[pitch]; 
                
                if (note) {
                    if (note.cancel) {
                        note.cancel();
                    } else if (note.source) {
                        try {
                            const t = audioContext.currentTime;
                            note.gain.gain.cancelScheduledValues(t);
                            if(note.legacy) {
                                note.gain.gain.linearRampToValueAtTime(0, t + 0.1);
                                note.source.stop(t + 0.1);
                            } else {
                                note.gain.gain.linearRampToValueAtTime(0, t + 0.1);
                                note.source.stop(t + 0.1);
                            }
                            
                            setTimeout(() => {
                                if (note.gain) note.gain.disconnect();
                                if (note.source) note.source.disconnect();
                            }, 200);

                        } catch(e) {}
                    }
                    delete this.playingNotes[pitch];
                }

                if(this.isRecordingMidi && this.recNotes[pitch]) {
                    const playTime = (audioContext.currentTime - this.startTime) % this.settings.duration;
                    let start = this.recNotes[pitch].start;
                    let dur = playTime - start;
                    if(dur < 0) dur += this.settings.duration;
                    
                    if (this.settings.useBpm) {
                        const beat = 60 / this.settings.bpm; 
                        const snap = beat / (this.settings.snap / 4);
                        start = Math.floor(start / snap) * snap;
                        dur = Math.max(snap, Math.round(dur / snap) * snap);
                    } else {
                        start = parseFloat(start.toFixed(3));
                        dur = parseFloat(dur.toFixed(3));
                    }
                    
                    const track = this.tracks.find(t => t.id === this.selectedTrackId);
                    if(track) { track.notes.push({ pitch, start, duration: dur, selected: false }); this.renderNotes(); }
                    delete this.recNotes[pitch];
                }
            },

            playInstrument(track, pitch, time, dur) {
                if(!audioContext) initContext();
                this.initPlayer();
                const transposePitch = pitch + track.transpose;
                const ctx = audioContext;
                const fx = this.getFxChain(ctx, track);

                if (track.type === 'sample' && track.data.buffer) {
                    const src = ctx.createBufferSource();
                    src.buffer = track.data.buffer;
                    const freq = 440 * Math.pow(2, (transposePitch - 69) / 12);
                    src.playbackRate.value = freq / 440;
                    const gain = ctx.createGain();
                    gain.gain.value = track.vol;
                    src.connect(gain);
                    gain.connect(fx.input);
                    fx.output.connect(masterGainNode);
                    src.start(time);
                    src.stop(time + dur);
                    
                    src.onended = () => {
                        gain.disconnect();
                        src.disconnect();
                    };
                } else {
                    const instr = getInstrumentData(track.type, track.instrument);
                    
                    if(instr && instr.cat === 'legacy') {
                        const freq = 440 * Math.pow(2, (transposePitch - 69) / 12);
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        
                        gain.gain.setValueAtTime(0, time);
                        
                        let n = osc;
                        let attack = 0.01;
                        let release = 0.1;

                        if(instr.legacyId === 'bell') {
                            osc.type = 'sine';
                            const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 800;
                            n.connect(hp); n = hp;
                            release = 1.0;
                        } else if(instr.legacyId === 'pad') {
                            osc.type = 'triangle';
                            const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1000;
                            n.connect(lp); n = lp;
                            attack = 0.5; release = 1.0;
                        } else if(instr.legacyId === '8bit') {
                            osc.type = 'square';
                            attack = 0.01; release = 0.05;
                        } else {
                            osc.type = 'triangle';
                        }

                        osc.frequency.setValueAtTime(freq, time);
                        n.connect(gain);
                        gain.connect(fx.input);
                        
                        gain.gain.linearRampToValueAtTime(track.vol, time + attack);
                        gain.gain.setValueAtTime(track.vol, time + dur - 0.01);
                        gain.gain.linearRampToValueAtTime(0, time + dur + release);
                        
                        osc.start(time);
                        osc.stop(time + dur + release);
                        
                        osc.onended = () => {
                             gain.disconnect();
                             osc.disconnect();
                        };
                    } else if (instr && window[instr.var]) {
                        const preset = window[instr.var];
                        this.player.queueWaveTable(ctx, fx.input, preset, time, pitch, dur, track.vol);
                        fx.output.connect(masterGainNode);
                    }
                }
            },
            togglePlay() { if(this.isPlaying) this.pause(); else this.play(); },
            play() { 
                if(!audioContext) initContext(); 
                if(this.isPlaying) return; 
                this.isPlaying = true; 
                this.nextNoteTime = audioContext.currentTime; 
                
                this.startTime = audioContext.currentTime - this.playbackOffset;
                
                document.getElementById('wsPlayBtn').textContent = 'II'; 
                this.scheduler(); 
                this.animLoop(); 
            },
            pause() {
                this.isPlaying = false;
                clearTimeout(this.timerID);
                if (audioContext) {
                    this.playbackOffset = (audioContext.currentTime - this.startTime) % this.settings.duration;
                }
                document.getElementById('wsPlayBtn').textContent = '►';
                
                this.isRecordingMidi = false;
                const setRec = (id) => document.getElementById(id).classList.remove('recording');
                setRec('wsRecBtn'); setRec('mobileRecBtn');
                if(this.player) this.player.cancelQueue(audioContext);
            },
            stop() { 
                this.isPlaying = false; 
                this.playbackOffset = 0;
                clearTimeout(this.timerID); 
                document.getElementById('wsPlayBtn').textContent = '►'; 
                document.getElementById('playhead').style.transform = 'translateX(0px)'; 
                this.isRecordingMidi = false; 
                const setRec = (id) => document.getElementById(id).classList.remove('recording');
                setRec('wsRecBtn'); setRec('mobileRecBtn');
                if(this.player) this.player.cancelQueue(audioContext);
            },
            scheduler() { while (this.nextNoteTime < audioContext.currentTime + this.scheduleAheadTime) { this.scheduleNotes(); this.nextNoteTime += 0.1; } if (this.isPlaying) this.timerID = setTimeout(() => this.scheduler(), this.lookahead); },
            scheduleNotes() {
                const currentSeqTime = (this.nextNoteTime - this.startTime) % this.settings.duration; 
                const lookaheadEnd = currentSeqTime + 0.1;
                this.tracks.forEach(track => { 
                    if(track.muted) return; 
                    track.notes.forEach(note => { 
                        if (note.start >= currentSeqTime && note.start < lookaheadEnd) 
                            this.playInstrument(track, note.pitch, this.nextNoteTime + (note.start - currentSeqTime), note.duration); 
                    }); 
                });
            },
            animLoop() { if(!this.isPlaying) return; const currentSeqTime = (audioContext.currentTime - this.startTime) % this.settings.duration; document.getElementById('playhead').style.transform = `translateX(${currentSeqTime * this.pixelsPerSecond}px)`; if(audioContext.currentTime - this.startTime > this.settings.duration) this.startTime = audioContext.currentTime; requestAnimationFrame(() => this.animLoop()); },
            updateSettings() { this.settings.bpm = parseInt(document.getElementById('wsBpm') ? document.getElementById('wsBpm').value : document.getElementById('fxBpmInput').value); const timeStr = document.getElementById('wsTimeLimit').value.split(':'); this.settings.duration = (+timeStr[0])*3600 + (+timeStr[1])*60 + (+timeStr[2]); this.settings.snap = parseInt(document.getElementById('wsGridSnap').value); this.resize(); },
            saveState() { const state = JSON.stringify({ tracks: this.tracks, settings: this.settings }); if(this.history[this.historyIndex] !== state) { this.history = this.history.slice(0, this.historyIndex + 1); this.history.push(state); this.historyIndex++; } },
            undo() { if(this.historyIndex > 0) { this.historyIndex--; this.loadState(this.history[this.historyIndex]); } },
            redo() { if(this.historyIndex < this.history.length - 1) { this.historyIndex++; this.loadState(this.history[this.historyIndex]); } },
            loadState(json) { const s = JSON.parse(json); this.tracks = s.tracks; this.settings = s.settings; this.renderTrackList(); this.renderNotes(); },
            reset() { 
                this.tracks = []; this.history = []; this.historyIndex = -1; this.addTrack('Piano', 'Acoustic Grand Piano'); 
                this.settings = { bpm: 120, duration: 30, snap: 16 };
                if(document.getElementById('wsBpm')) document.getElementById('wsBpm').value = 120;
                document.getElementById('wsTimeLimit').value = "00:00:30";
                document.getElementById('wsTranspose').value = 1;
                document.getElementById('wsTransposeInput').value = 1;
                document.getElementById('wsTrackVol').value = 0.5;
                document.getElementById('wsTrackVolInput').value = 0.5;
                
                document.getElementById('fxDistortion').value = 0;
                document.getElementById('fxDistortionInput').value = 0;
                document.getElementById('fxReverb').value = 0;
                document.getElementById('fxReverbInput').value = 0;
                document.getElementById('fxBitrate').value = 16;
                document.getElementById('fxBitrateInput').value = 16;
                for(let i=0;i<9;i++) { const sl=document.getElementById(`fxEq${i}`); if(sl) sl.value=0; }
                
                this.keyboardOctaveOffset = 0;
                document.getElementById('mobilePitchInput').value = 0;
                
                this.renderTrackList(); this.renderNotes(); this.resize(); 
            },
            async export(format) {
                hideExportModal();
                const btn = document.getElementById('exportBtn');
                const originalText = btn.textContent;
                btn.textContent = '…';
                btn.disabled = true;

                try {
                    const dur = this.settings.duration;
                    const ctx = new OfflineAudioContext(2, 44100 * dur, 44100);
                    this.initPlayer();

                    const master = ctx.createGain();
                    master.gain.value = 1.0;
                    master.connect(ctx.destination);

                    this.tracks.forEach(track => {
                        if (track.muted) return;

                        const fx = this.getFxChain(ctx, track);
                        fx.output.connect(master);

                        track.notes.forEach(note => {
                            const start = note.start;
                            const duration = note.duration;
                            const pitch = note.pitch + track.transpose;

                            if (track.type === 'sample' && track.data.buffer) {
                                const src = ctx.createBufferSource();
                                src.buffer = track.data.buffer;
                                const freq = 440 * Math.pow(2, (pitch - 69) / 12);
                                src.playbackRate.value = freq / 440;
                                const gain = ctx.createGain();
                                gain.gain.value = track.vol;
                                src.connect(gain);
                                gain.connect(fx.input);
                                src.start(start);
                                src.stop(start + duration);
                            } else {
                                const instr = getInstrumentData(track.type, track.instrument);
                                if(instr && instr.cat === 'legacy') {
                                    const freq = 440 * Math.pow(2, (pitch - 69) / 12);
                                    const osc = ctx.createOscillator();
                                    const gain = ctx.createGain();
                                    
                                    gain.gain.setValueAtTime(0, start);
                                    
                                    let n = osc;
                                    let attack = 0.01;
                                    let release = 0.1;

                                    if(instr.legacyId === 'bell') {
                                        osc.type = 'sine';
                                        const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 800;
                                        n.connect(hp); n = hp;
                                        release = 1.0;
                                    } else if(instr.legacyId === 'pad') {
                                        osc.type = 'triangle';
                                        const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1000;
                                        n.connect(lp); n = lp;
                                        attack = 0.5; release = 1.0;
                                    } else if(instr.legacyId === '8bit') {
                                        osc.type = 'square';
                                        attack = 0.01; release = 0.05;
                                    } else {
                                        osc.type = 'triangle';
                                    }

                                    osc.frequency.setValueAtTime(freq, start);
                                    n.connect(gain);
                                    gain.connect(fx.input);
                                    
                                    gain.gain.linearRampToValueAtTime(track.vol, start + attack);
                                    gain.gain.setValueAtTime(track.vol, start + duration - 0.01);
                                    gain.gain.linearRampToValueAtTime(0, start + duration + release);
                                    
                                    osc.start(start);
                                    osc.stop(start + duration + release);
                                } else if (instr && window[instr.var]) {
                                    const preset = window[instr.var];
                                    this.player.queueWaveTable(ctx, fx.input, preset, start, pitch, duration, track.vol);
                                }
                            }
                        });
                    });

                    const b = await ctx.startRendering();
                    if (format === 'wav') downloadBlob(new Blob([bufferToWav(b, {}, {})], { type: 'audio/wav' }), 'project.wav');
                    else if (format === 'mp3') downloadBlob(audioBufferToMp3(b), 'project.mp3');
                    else if (format === 'ogg') downloadBlob(await audioBufferToOgg(b, {}), 'project.ogg');

                } catch(err) {
                    console.error(err);
                    alert('Export failed.');
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            },
            saveProject() {
                const data = JSON.stringify({ tracks: this.tracks, settings: this.settings });
                const blob = new Blob([data], { type: 'application/json' });
                downloadBlob(blob, 'project.json');
            },
            loadProject(json) {
                try {
                    this.loadState(json);
                    alert('Project loaded successfully!');
                } catch(e) {
                    alert('Error loading project.');
                }
            }
        };
        
        function addToSequencer() {
            if (currentMode === 0) { const s = getSettingsFromUI(); const name = prompt("Name this synth sound:", "My Synth"); if(name) DAW.addTrack('synth', name, s); } 
            else if (currentMode === 1 && audioFileBuffer) { const name = prompt("Name this sample:", loadedFileInfo.name); if(name) DAW.addTrack('sample', name, { buffer: audioFileBuffer }); } 
            else alert("Nothing to add.");
            cycleMode(); cycleMode();
        }

        function handleKeyboardShortcuts(e) {
            if (document.activeElement.tagName.match(/INPUT|TEXTAREA/i)) return;
            if (currentMode === 2) {
                
                if (e.key === '=' || e.key === '+') { DAW.zoom(0.2); return; }
                if (e.key === '-' || e.key === '_') { DAW.zoom(-0.2); return; }
                
                if (e.type === 'keydown') {
                    if (e.ctrlKey) {
                        if (e.key === 'a') { e.preventDefault(); DAW.selectAllNotes(); return; }
                        if (e.key === 'd') { e.preventDefault(); DAW.duplicateSelection(); return; }
                        if (e.key === 'z') { e.preventDefault(); DAW.undo(); return; }
                        if (e.key === 'y') { e.preventDefault(); DAW.redo(); return; }
                        if (e.key === 'c') { e.preventDefault(); DAW.gridCopy(); return; }
                        if (e.key === 'v') { e.preventDefault(); DAW.gridPaste(); return; }
                        if (e.key === 'x') { e.preventDefault(); DAW.gridCut(); return; }
                    }

                    if(e.code === 'Backspace' || e.code === 'Delete') { e.preventDefault(); DAW.gridDelete(); return; }
                    
                    const mobileKeysVisible = document.getElementById('mobileKeyboard').style.display === 'flex';
                    if (mobileKeysVisible && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                         e.preventDefault();
                         let delta = e.key === 'ArrowUp' ? 12 : -12;
                         DAW.keyboardOctaveOffset += delta;
                         
                         if(DAW.keyboardOctaveOffset > 36) DAW.keyboardOctaveOffset = 36; 
                         if(DAW.keyboardOctaveOffset < -24) DAW.keyboardOctaveOffset = -24; 
                         document.getElementById('mobilePitchInput').value = DAW.keyboardOctaveOffset / 12;
                         DAW.setupMobileKeyboard();
                         return;
                    }
                    
                    if (!mobileKeysVisible && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                        e.preventDefault();
                        const slider = document.getElementById('wsTrackVol');
                        let val = parseFloat(slider.value) + (e.key === 'ArrowUp' ? 0.1 : -0.1);
                        if(val > 2) val = 2; if(val < 0) val = 0;
                        slider.value = val;
                        DAW.updateTrackVol(slider);
                        return;
                    }
                    
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        e.preventDefault();
                        const t = DAW.tracks.find(x => x.id === DAW.selectedTrackId);
                        const hasSelection = t && t.notes.some(n => n.selected);
                        
                        if (hasSelection) {
                            DAW.dpadMove(e.key === 'ArrowRight' ? 1 : -1, 0);
                        } else {
                            const grid = document.getElementById('gridContainer');
                            grid.scrollLeft += (e.key === 'ArrowRight' ? 50 : -50);
                        }
                        return;
                    }
                }

                const map = { 
                    'z':48, 's':49, 'x':50, 'd':51, 'c':52, 'v':53, 'g':54, 'b':55, 'h':56, 'n':57, 'j':58, 'm':59, ',':60, 'l':61, '.':62, ';':63, '/':64,
                    'q':60, '2':61, 'w':62, '3':63, 'e':64, 'r':65, '5':66, 't':67, '6':68, 'y':69, '7':70, 'u':71, 'i':72, '9':73, 'o':74, '0':75, 'p':76
                };
                
                let rawPitch = map[e.key.toLowerCase()];
                if (rawPitch) {
                    const pitch = rawPitch + DAW.keyboardOctaveOffset;
                    if (e.type === 'keydown') {
                         if (!DAW.activeKeys[pitch]) { 
                             DAW.activeKeys[pitch] = true; 
                             DAW.startRealtimeNote(pitch); 
                         }
                    } else if (e.type === 'keyup') {
                         if (DAW.activeKeys[pitch]) { 
                             DAW.activeKeys[pitch] = false; 
                             DAW.stopRealtimeNote(pitch); 
                         }
                    }
                    return;
                }
                
                if (e.type === 'keydown' && e.code === 'Space') { e.preventDefault(); DAW.togglePlay(); return; }
                
                return;
            }
            if (e.type === 'keydown') {
                if (e.code === 'Space') { e.preventDefault(); if (isAudioFileLoaded) toggleAudioPlayback(); else if (loopMode === 0) playCustomSound(); }
                if (isAudioFileLoaded && (e.code === 'ArrowLeft' || e.code === 'ArrowRight')) {
                    e.preventDefault(); if (!audioFileBuffer) return;
                    const t = playbackStartOffset + (isPlaying ? (audioContext.currentTime - playbackStartTime) : 0) + (e.code === 'ArrowLeft' ? -5 : 5);
                    const nt = Math.max(0, Math.min(audioFileBuffer.duration, t));
                    if (videoElement.src) videoElement.currentTime = nt;
                    if (isPlaying) { stopCurrentSound(); playAudioFile(nt); } else { playbackStartOffset = nt; document.getElementById('progressBar').style.width = `${(nt / audioFileBuffer.duration) * 100}%`; }
                }
            }
        }
    </script>
</body>
</html>
